{
  "language": "Solidity",
  "sources": {
    "src/HooksFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport './libraries/LibERC20.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './ReentrancyGuard.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './access/IHooks.sol';\nimport './IHooksFactory.sol';\nimport './types/TransientBytesArray.sol';\nimport './spherex/SphereXProtectedRegisteredBase.sol';\n\nstruct TmpMarketParameterStorage {\n  address borrower;\n  address asset;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  bytes32 packedNameWord0;\n  bytes32 packedNameWord1;\n  bytes32 packedSymbolWord0;\n  bytes32 packedSymbolWord1;\n  uint8 decimals;\n  HooksConfig hooks;\n}\n\ncontract HooksFactory is SphereXProtectedRegisteredBase, ReentrancyGuard, IHooksFactory {\n  using LibERC20 for address;\n\n  TransientBytesArray internal constant _tmpMarketParameters =\n    TransientBytesArray.wrap(uint256(keccak256('Transient:TmpMarketParametersStorage')) - 1);\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  address public immutable override marketInitCodeStorage;\n\n  uint256 public immutable override marketInitCodeHash;\n\n  address public immutable override sanctionsSentinel;\n  address[] internal _hooksTemplates;\n  mapping(address hooksTemplate => HooksTemplate details) internal _templateDetails;\n  mapping(address hooksInstance => address hooksTemplate)\n    public\n    override getHooksTemplateForInstance;\n\n  constructor(\n    address archController_,\n    address _sanctionsSentinel,\n    address _marketInitCodeStorage,\n    uint256 _marketInitCodeHash\n  ) {\n    marketInitCodeStorage = _marketInitCodeStorage;\n    marketInitCodeHash = _marketInitCodeHash;\n    _archController = archController_;\n    sanctionsSentinel = _sanctionsSentinel;\n    __SphereXProtectedRegisteredBase_init(IWildcatArchController(archController_).sphereXEngine());\n  }\n\n  function registerWithArchController() external override {\n    IWildcatArchController(_archController).registerController(address(this));\n  }\n\n  function archController() external view override returns (address) {\n    return _archController;\n  }\n\n  // ========================================================================== //\n  //                          Internal Storage Helpers                          //\n  // ========================================================================== //\n\n  /**\n   * @dev Get the temporary market parameters from transient storage.\n   */\n  function _getTmpMarketParameters()\n    internal\n    view\n    returns (TmpMarketParameterStorage memory parameters)\n  {\n    return abi.decode(_tmpMarketParameters.read(), (TmpMarketParameterStorage));\n  }\n\n  /**\n   * @dev Set the temporary market parameters in transient storage.\n   */\n  function _setTmpMarketParameters(TmpMarketParameterStorage memory parameters) internal {\n    _tmpMarketParameters.write(abi.encode(parameters));\n  }\n\n  // ========================================================================== //\n  //                                  Modifiers                                 //\n  // ========================================================================== //\n\n  modifier onlyArchControllerOwner() {\n    if (msg.sender != IWildcatArchController(_archController).owner()) {\n      revert CallerNotArchControllerOwner();\n    }\n    _;\n  }\n\n  // ========================================================================== //\n  //                               Hooks Templates                              //\n  // ========================================================================== //\n\n  function addHooksTemplate(\n    address hooksTemplate,\n    string calldata name,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external override onlyArchControllerOwner {\n    if (_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateAlreadyExists();\n    }\n    _validateFees(feeRecipient, originationFeeAsset, originationFeeAmount, protocolFeeBips);\n    _templateDetails[hooksTemplate] = HooksTemplate({\n      exists: true,\n      name: name,\n      feeRecipient: feeRecipient,\n      originationFeeAsset: originationFeeAsset,\n      originationFeeAmount: originationFeeAmount,\n      protocolFeeBips: protocolFeeBips,\n      enabled: true,\n      index: uint24(_hooksTemplates.length)\n    });\n    _hooksTemplates.push(hooksTemplate);\n    emit HooksTemplateAdded(\n      hooksTemplate,\n      name,\n      feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      protocolFeeBips\n    );\n  }\n\n  function _validateFees(\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) internal pure {\n    bool hasOriginationFee = originationFeeAmount > 0;\n    bool nullFeeRecipient = feeRecipient == address(0);\n    bool nullOriginationFeeAsset = originationFeeAsset == address(0);\n    if (\n      (protocolFeeBips > 0 && nullFeeRecipient) ||\n      (hasOriginationFee && nullFeeRecipient) ||\n      (hasOriginationFee && nullOriginationFeeAsset) ||\n      protocolFeeBips > 10000\n    ) {\n      revert InvalidFeeConfiguration();\n    }\n  }\n\n  /// @dev Update the fees for a hooks template\n  /// Note: The new fee structure will apply to all NEW markets created with existing\n  ///       or future instances of the hooks template, but not to existing markets.\n  function updateHooksTemplateFees(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external override onlyArchControllerOwner {\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    _validateFees(feeRecipient, originationFeeAsset, originationFeeAmount, protocolFeeBips);\n    HooksTemplate storage template = _templateDetails[hooksTemplate];\n    template.feeRecipient = feeRecipient;\n    template.originationFeeAsset = originationFeeAsset;\n    template.originationFeeAmount = originationFeeAmount;\n    template.protocolFeeBips = protocolFeeBips;\n    emit HooksTemplateFeesUpdated(\n      hooksTemplate,\n      feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      protocolFeeBips\n    );\n  }\n\n  function disableHooksTemplate(address hooksTemplate) external override onlyArchControllerOwner {\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    _templateDetails[hooksTemplate].enabled = false;\n    // Emit an event to indicate that the template has been removed\n    emit HooksTemplateDisabled(hooksTemplate);\n  }\n\n  function getHooksTemplateDetails(\n    address hooksTemplate\n  ) external view override returns (HooksTemplate memory) {\n    return _templateDetails[hooksTemplate];\n  }\n\n  function isHooksTemplate(address hooksTemplate) external view override returns (bool) {\n    return _templateDetails[hooksTemplate].exists;\n  }\n\n  function getHooksTemplates() external view override returns (address[] memory) {\n    return _hooksTemplates;\n  }\n\n  // ========================================================================== //\n  //                               Hooks Instances                              //\n  // ========================================================================== //\n\n  /// @dev Deploy a hooks instance for an approved template with constructor args.\n  ///      Callable by approved borrowers on the arch-controller.\n  ///      May require payment of origination fees.\n  function deployHooksInstance(\n    address hooksTemplate,\n    bytes calldata constructorArgs\n  ) external override returns (address hooksInstance) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    hooksInstance = _deployHooksInstance(hooksTemplate, constructorArgs);\n  }\n\n  function isHooksInstance(address hooksInstance) external view override returns (bool) {\n    return getHooksTemplateForInstance[hooksInstance] != address(0);\n  }\n\n  function _deployHooksInstance(\n    address hooksTemplate,\n    bytes calldata constructorArgs\n  ) internal returns (address hooksInstance) {\n    HooksTemplate storage template = _templateDetails[hooksTemplate];\n    if (!template.exists) {\n      revert HooksTemplateNotFound();\n    }\n    if (!template.enabled) {\n      revert HooksTemplateNotAvailable();\n    }\n\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(hooksTemplate), 1)\n      // Copy code from target address to memory starting at byte 1\n      extcodecopy(hooksTemplate, initCodePointer, 1, initCodeSize)\n      let endInitCodePointer := add(initCodePointer, initCodeSize)\n      // Write the address of the caller as the first parameter\n      mstore(endInitCodePointer, caller())\n      // Write the offset to the encoded constructor args\n      mstore(add(endInitCodePointer, 0x20), 0x40)\n      // Write the length of the encoded constructor args\n      let constructorArgsSize := constructorArgs.length\n      mstore(add(endInitCodePointer, 0x40), constructorArgsSize)\n      // Copy constructor args to initcode after the bytes length\n      calldatacopy(add(endInitCodePointer, 0x60), constructorArgs.offset, constructorArgsSize)\n      // Get the full size of the initcode with the constructor args\n      let initCodeSizeWithArgs := add(add(initCodeSize, 0x60), constructorArgsSize)\n      // Deploy the contract with the initcode\n      hooksInstance := create(0, initCodePointer, initCodeSizeWithArgs)\n      if iszero(hooksInstance) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n\n    emit HooksInstanceDeployed(hooksInstance, hooksTemplate);\n    getHooksTemplateForInstance[hooksInstance] = hooksTemplate;\n  }\n\n  // ========================================================================== //\n  //                                   Markets                                  //\n  // ========================================================================== //\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters()\n    external\n    view\n    override\n    returns (MarketParameters memory parameters)\n  {\n    TmpMarketParameterStorage memory tmp = _getTmpMarketParameters();\n\n    parameters.asset = tmp.asset;\n    parameters.packedNameWord0 = tmp.packedNameWord0;\n    parameters.packedNameWord1 = tmp.packedNameWord1;\n    parameters.packedSymbolWord0 = tmp.packedSymbolWord0;\n    parameters.packedSymbolWord1 = tmp.packedSymbolWord1;\n    parameters.decimals = tmp.decimals;\n    parameters.borrower = tmp.borrower;\n    parameters.feeRecipient = tmp.feeRecipient;\n    parameters.sentinel = sanctionsSentinel;\n    parameters.maxTotalSupply = tmp.maxTotalSupply;\n    parameters.protocolFeeBips = tmp.protocolFeeBips;\n    parameters.annualInterestBips = tmp.annualInterestBips;\n    parameters.delinquencyFeeBips = tmp.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = tmp.withdrawalBatchDuration;\n    parameters.reserveRatioBips = tmp.reserveRatioBips;\n    parameters.delinquencyGracePeriod = tmp.delinquencyGracePeriod;\n    parameters.archController = _archController;\n    parameters.sphereXEngine = sphereXEngine();\n    parameters.hooks = tmp.hooks;\n  }\n\n  function computeMarketAddress(bytes32 salt) external view override returns (address) {\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /**\n   * @dev Given a string of at most 63 bytes, produces a packed version with two words,\n   *      where the first word contains the length byte and the first 31 bytes of the string,\n   *      and the second word contains the second 32 bytes of the string.\n   */\n  function _packString(string memory str) internal pure returns (bytes32 word0, bytes32 word1) {\n    assembly {\n      let length := mload(str)\n      // Equivalent to:\n      // if (str.length > 63) revert NameOrSymbolTooLong();\n      if gt(length, 0x3f) {\n        mstore(0, 0x19a65cb6)\n        revert(0x1c, 0x04)\n      }\n      // Load the length and first 31 bytes of the string into the first word\n      // by reading from 31 bytes after the length pointer.\n      word0 := mload(add(str, 0x1f))\n      // If the string is less than 32 bytes, the second word will be zeroed out.\n      word1 := mul(mload(add(str, 0x3f)), gt(mload(str), 0x1f))\n    }\n  }\n\n  function _deployMarket(\n    DeployMarketInputs memory parameters,\n    bytes memory hooksData,\n    HooksTemplate memory template,\n    bytes32 salt\n  ) internal returns (address market) {\n    if (IWildcatArchController(_archController).isBlacklistedAsset(parameters.asset)) {\n      revert AssetBlacklisted();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n\n    if (!(address(bytes20(salt)) == msg.sender || bytes20(salt) == bytes20(0))) {\n      revert SaltDoesNotContainSender();\n    }\n\n    if (template.originationFeeAsset != address(0)) {\n      template.originationFeeAsset.safeTransferFrom(\n        msg.sender,\n        template.feeRecipient,\n        template.originationFeeAmount\n      );\n    }\n\n    parameters.hooks = parameters.hooks.mergeFlags(IHooks(hooksInstance).config());\n\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n\n    IHooks(hooksInstance).onCreateMarket(msg.sender, market, parameters, hooksData);\n    uint8 decimals = parameters.asset.decimals();\n\n    string memory name = string.concat(parameters.namePrefix, parameters.asset.name());\n    string memory symbol = string.concat(parameters.symbolPrefix, parameters.asset.symbol());\n\n    TmpMarketParameterStorage memory tmp = TmpMarketParameterStorage({\n      borrower: msg.sender,\n      asset: parameters.asset,\n      packedNameWord0: bytes32(0),\n      packedNameWord1: bytes32(0),\n      packedSymbolWord0: bytes32(0),\n      packedSymbolWord1: bytes32(0),\n      decimals: decimals,\n      feeRecipient: template.feeRecipient,\n      protocolFeeBips: template.protocolFeeBips,\n      maxTotalSupply: parameters.maxTotalSupply,\n      annualInterestBips: parameters.annualInterestBips,\n      delinquencyFeeBips: parameters.delinquencyFeeBips,\n      withdrawalBatchDuration: parameters.withdrawalBatchDuration,\n      reserveRatioBips: parameters.reserveRatioBips,\n      delinquencyGracePeriod: parameters.delinquencyGracePeriod,\n      hooks: parameters.hooks\n    });\n    {\n      (tmp.packedNameWord0, tmp.packedNameWord1) = _packString(name);\n      (tmp.packedSymbolWord0, tmp.packedSymbolWord1) = _packString(symbol);\n    }\n\n    _setTmpMarketParameters(tmp);\n\n    if (market.code.length != 0) {\n      revert MarketAlreadyExists();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    IWildcatArchController(_archController).registerMarket(market);\n\n    _tmpMarketParameters.setEmpty();\n\n    emit MarketDeployed(\n      market,\n      name,\n      symbol,\n      tmp.asset,\n      tmp.maxTotalSupply,\n      tmp.annualInterestBips,\n      tmp.delinquencyFeeBips,\n      tmp.withdrawalBatchDuration,\n      tmp.reserveRatioBips,\n      tmp.delinquencyGracePeriod,\n      tmp.hooks\n    );\n  }\n\n  function deployMarket(\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt\n  ) external override returns (address market) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n    address hooksTemplate = getHooksTemplateForInstance[hooksInstance];\n    if (hooksTemplate == address(0)) {\n      revert HooksInstanceNotFound();\n    }\n    HooksTemplate memory template = _templateDetails[hooksTemplate];\n    market = _deployMarket(parameters, hooksData, template, salt);\n  }\n\n  function deployMarketAndHooks(\n    address hooksTemplate,\n    bytes calldata hooksTemplateArgs,\n    DeployMarketInputs memory parameters,\n    bytes calldata hooksData,\n    bytes32 salt\n  ) external override returns (address market, address hooksInstance) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    HooksTemplate memory template = _templateDetails[hooksTemplate];\n    hooksInstance = _deployHooksInstance(hooksTemplate, hooksTemplateArgs);\n    parameters.hooks = parameters.hooks.setHooksAddress(hooksInstance);\n    market = _deployMarket(parameters, hooksData, template, salt);\n  }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/libraries/LibERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './StringQuery.sol';\n\n/// @notice Safe ERC20 library\n/// @author d1ll0n\n/// @notice Changes from solady:\n///   - Removed Permit2 and ETH functions\n///   - `balanceOf(address)` reverts if the call fails or does not return >=32 bytes\n///   - Added queries for `name`, `symbol`, `decimals`\n///   - Set name to LibERC20 as it has queries unrelated to transfers and ETH functions were removed\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibERC20.sol)\n/// @author Previously modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibERC20.sol)\n///\n/// @dev Note:\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary LibERC20 {\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                       CUSTOM ERRORS                        */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev The ERC20 `transferFrom` has failed.\n  error TransferFromFailed();\n\n  /// @dev The ERC20 `transfer` has failed.\n  error TransferFailed();\n\n  /// @dev The ERC20 `balanceOf` call has failed.\n  error BalanceOfFailed();\n\n  /// @dev The ERC20 `name` call has failed.\n  error NameFailed();\n\n  /// @dev The ERC20 `symbol` call has failed.\n  error SymbolFailed();\n\n  /// @dev The ERC20 `decimals` call has failed.\n  error DecimalsFailed();\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                      ERC20 OPERATIONS                      */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n  /// Reverts upon failure.\n  ///\n  /// The `from` account must have at least `amount` approved for\n  /// the current contract to manage.\n  function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let m := mload(0x40) // Cache the free memory pointer.\n      mstore(0x60, amount) // Store the `amount` argument.\n      mstore(0x40, to) // Store the `to` argument.\n      mstore(0x2c, shl(96, from)) // Store the `from` argument.\n      mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n      // Perform the transfer, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n          call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x60, 0) // Restore the zero slot to zero.\n      mstore(0x40, m) // Restore the free memory pointer.\n    }\n  }\n\n  /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n  /// Reverts upon failure.\n  function safeTransfer(address token, address to, uint256 amount) internal {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x14, to) // Store the `to` argument.\n      mstore(0x34, amount) // Store the `amount` argument.\n      mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n      // Perform the transfer, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n          call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n    }\n  }\n\n  /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n  /// Reverts upon failure.\n  function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n      mstore(0x20, address()) // Store the address of the current contract.\n      // Read the balance, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n          staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x14, to) // Store the `to` argument.\n      amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n      mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n      // Perform the transfer, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n          call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n    }\n  }\n\n  /// @dev Returns the amount of ERC20 `token` owned by `account`.\n  /// Reverts if the call to `balanceOf` reverts or returns less than 32 bytes.\n  function balanceOf(address token, address account) internal view returns (uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n      mstore(0x20, account) // Store the `account` argument.\n      // Read the balance, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n          staticcall(gas(), token, 0x1c, 0x24, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x4963f6d5) // `BalanceOfFailed()`.\n        revert(0x1c, 0x04)\n      }\n      amount := mload(0x00)\n    }\n  }\n\n  /// @dev Returns the `decimals` of ERC20 `token`.\n  /// Reverts if the call to `decimals` reverts or returns less than 32 bytes.\n  function decimals(address token) internal view returns (uint8 _decimals) {\n    assembly {\n      // Write selector for `decimals()` to the end of the first word\n      // of scratch space.\n      mstore(0, 0x313ce567)\n      // Call `asset.decimals()`, writing up to 32 bytes of returndata\n      // to scratch space, overwriting the calldata used for the call.\n      // Reverts if the call fails, does not return exactly 32 bytes, or the returndata\n      // exceeds 8 bits.\n      if iszero(\n        and(\n          and(eq(returndatasize(), 0x20), lt(mload(0), 0x100)),\n          staticcall(gas(), token, 0x1c, 0x04, 0, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x3394d170) // `DecimalsFailed()`.\n        revert(0x1c, 0x04)\n      }\n      // Read the return value from scratch space\n      _decimals := mload(0)\n    }\n  }\n\n  /// @dev Returns the `name` of ERC20 `token`.\n  /// Reverts if the call to `name` reverts or returns a value which is neither\n  /// a bytes32 string nor a valid ABI-encoded string.\n  function name(address token) internal view returns (string memory) {\n    // The `name` function selector is 0x06fdde03.\n    // The `NameFailed` error selector is 0x2ed09f54.\n    return queryStringOrBytes32AsString(token, 0x06fdde03, 0x2ed09f54);\n  }\n\n  /// @dev Returns the `symbol` of ERC20 `token`.\n  /// Reverts if the call to `symbol` reverts or returns a value which is neither\n  /// a bytes32 string nor a valid ABI-encoded string.\n  function symbol(address token) internal view returns (string memory) {\n    // The `symbol` function selector is 0x95d89b41.\n    // The `SymbolFailed` error selector is 0x3ddcc60a.\n    return queryStringOrBytes32AsString(token, 0x95d89b41, 0x3ddcc60a);\n  }\n}\n"
    },
    "src/interfaces/IWildcatArchController.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\ninterface IWildcatArchController {\n  error NotMarketFactory();\n\n  error NotControllerFactory();\n\n  function owner() external view returns (address);\n\n  // ========================================================================== //\n  //                               SphereX Config                               //\n  // ========================================================================== //\n\n  event ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin);\n\n  event ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress);\n\n  event SpherexAdminTransferStarted(address currentAdmin, address pendingAdmin);\n\n  event SpherexAdminTransferCompleted(address oldAdmin, address newAdmin);\n\n  event NewAllowedSenderOnchain(address sender);\n\n  error SphereXOperatorRequired();\n\n  error SphereXAdminRequired();\n\n  error SphereXOperatorOrAdminRequired();\n\n  error SphereXNotPendingAdmin();\n\n  error SphereXNotEngine();\n\n  function pendingSphereXAdmin() external view returns (address);\n\n  function sphereXAdmin() external view returns (address);\n\n  function sphereXOperator() external view returns (address);\n\n  function sphereXEngine() external view returns (address);\n\n  function transferSphereXAdminRole(address newAdmin) external virtual;\n\n  function acceptSphereXAdminRole() external virtual;\n\n  function changeSphereXOperator(address newSphereXOperator) external;\n\n  function changeSphereXEngine(address newSphereXEngine) external;\n\n  // ========================================================================== //\n  //                         Controller Factory Registry                        //\n  // ========================================================================== //\n\n  event ControllerFactoryAdded(address);\n\n  event ControllerFactoryRemoved(address);\n\n  function getRegisteredControllerFactories() external view returns (address[] memory);\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256);\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool);\n\n  function registerControllerFactory(address factory) external;\n\n  function removeControllerFactory(address factory) external;\n\n  // ========================================================================== //\n  //                             Controller Registry                            //\n  // ========================================================================== //\n\n  event ControllerAdded(address, address);\n\n  event ControllerRemoved(address);\n\n  function getRegisteredControllers() external view returns (address[] memory);\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredControllersCount() external view returns (uint256);\n\n  function isRegisteredController(address controller) external view returns (bool);\n\n  function registerController(address controller) external;\n\n  function removeController(address controller) external;\n\n  // ========================================================================== //\n  //                             Borrowers Registry                             //\n  // ========================================================================== //\n\n  event BorrowerAdded(address);\n\n  event BorrowerRemoved(address);\n\n  function getRegisteredBorrowers() external view returns (address[] memory);\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredBorrowersCount() external view returns (uint256);\n\n  function isRegisteredBorrower(address borrower) external view returns (bool);\n\n  function registerBorrower(address borrower) external;\n\n  function removeBorrower(address borrower) external;\n\n  // ========================================================================== //\n  //                          Asset Blacklist Registry                          //\n  // ========================================================================== //\n\n  event AssetPermitted();\n\n  event AssetBlacklisted();\n\n  function addBlacklist(address asset) external;\n\n  function removeBlacklist(address asset) external;\n\n  function isBlacklistedAsset(address asset) external view returns (bool);\n\n  function getBlacklistedAssets() external view returns (address[] memory);\n\n  function getBlacklistedAssets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getBlacklistedAssetsCount() external view returns (uint256);\n\n  // ========================================================================== //\n  //                               Markets Registry                             //\n  // ========================================================================== //\n\n  event MarketAdded(address, address);\n\n  event MarketRemoved(address);\n\n  function getRegisteredMarkets() external view returns (address[] memory);\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredMarketsCount() external view returns (uint256);\n\n  function isRegisteredMarket(address market) external view returns (bool);\n\n  function registerMarket(address market) external;\n\n  function removeMarket(address market) external;\n}\n"
    },
    "src/libraries/LibStoredInitCode.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.24;\n\nlibrary LibStoredInitCode {\n  error InitCodeDeploymentFailed();\n  error DeploymentFailed();\n\n  function deployInitCode(bytes memory data) internal returns (address initCodeStorage) {\n    assembly {\n      let size := mload(data)\n      let createSize := add(size, 0x0b)\n      // Prefix Code\n      //\n      // Has trailing STOP instruction so the deployed data\n      // can not be executed as a smart contract.\n      //\n      // Instruction                | Stack\n      // ----------------------------------------------------\n      // PUSH2 size                 | size                  |\n      // PUSH0                      | 0, size               |\n      // DUP2                       | size, 0, size         |\n      // PUSH1 10 (offset to STOP)  | 10, size, 0, size     |\n      // PUSH0                      | 0, 10, size, 0, size  |\n      // CODECOPY                   | 0, size               |\n      // RETURN                     |                       |\n      // STOP                       |                       |\n      // ----------------------------------------------------\n\n      // Shift (size + 1) to position it in front of the PUSH2 instruction.\n      // Reuse `data.length` memory for the create prefix to avoid\n      // unnecessary memory allocation.\n      mstore(data, or(shl(64, add(size, 1)), 0x6100005f81600a5f39f300))\n      // Deploy the code storage\n      initCodeStorage := create(0, add(data, 21), createSize)\n      // if (initCodeStorage == address(0)) revert InitCodeDeploymentFailed();\n      if iszero(initCodeStorage) {\n        mstore(0, 0x11c8c3c0)\n        revert(0x1c, 0x04)\n      }\n      // Restore `data.length`\n      mstore(data, size)\n    }\n  }\n\n  /**\n   * @dev Returns the create2 prefix for a given deployer address.\n   *      Equivalent to `uint256(uint160(deployer)) | (0xff << 160)`\n   */\n  function getCreate2Prefix(address deployer) internal pure returns (uint256 create2Prefix) {\n    assembly {\n      create2Prefix := or(deployer, 0xff0000000000000000000000000000000000000000)\n    }\n  }\n\n  function calculateCreate2Address(\n    uint256 create2Prefix,\n    bytes32 salt,\n    uint256 initCodeHash\n  ) internal pure returns (address create2Address) {\n    assembly {\n      // Cache the free memory pointer so it can be restored at the end\n      let freeMemoryPointer := mload(0x40)\n\n      // Write 0xff + address to bytes 11:32\n      mstore(0x00, create2Prefix)\n\n      // Write salt to bytes 32:64\n      mstore(0x20, salt)\n\n      // Write initcode hash to bytes 64:96\n      mstore(0x40, initCodeHash)\n\n      // Calculate create2 address\n      create2Address := and(keccak256(0x0b, 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n\n      // Restore the free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  function createWithStoredInitCode(address initCodeStorage) internal returns (address deployment) {\n    deployment = createWithStoredInitCode(initCodeStorage, 0);\n  }\n\n  function createWithStoredInitCode(\n    address initCodeStorage,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create(value, initCodePointer, initCodeSize)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt\n  ) internal returns (address deployment) {\n    deployment = create2WithStoredInitCode(initCodeStorage, salt, 0);\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create2(value, initCodePointer, initCodeSize, salt)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value,\n    bytes memory constructorArgs\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      // Copy code from target address to memory starting at byte 1\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      // Copy constructor args from memory to initcode\n      let constructorArgsSize := mload(constructorArgs)\n      mcopy(add(initCodePointer, initCodeSize), add(constructorArgs, 0x20), constructorArgsSize)\n      let initCodeSizeWithArgs := add(initCodeSize, constructorArgsSize)\n      deployment := create2(value, initCodePointer, initCodeSizeWithArgs, salt)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    bytes memory constructorArgs\n  ) internal returns (address deployment) {\n    return create2WithStoredInitCode(initCodeStorage, salt, 0, constructorArgs);\n  }\n\n  function create2WithStoredInitCodeCD(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value,\n    bytes calldata constructorArgs\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      // Copy code from target address to memory starting at byte 1\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      // Copy constructor args from calldata to end of initcode\n      let constructorArgsSize := constructorArgs.length\n      calldatacopy(add(initCodePointer, initCodeSize), constructorArgs.offset, constructorArgsSize)\n      let initCodeSizeWithArgs := add(initCodeSize, constructorArgsSize)\n      deployment := create2(value, initCodePointer, initCodeSizeWithArgs, salt)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCodeCD(\n    address initCodeStorage,\n    bytes32 salt,\n    bytes calldata constructorArgs\n  ) internal returns (address deployment) {\n    return create2WithStoredInitCodeCD(initCodeStorage, salt, 0, constructorArgs);\n  }\n}\n"
    },
    "src/libraries/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './Errors.sol';\n\nuint256 constant BIP = 1e4;\nuint256 constant HALF_BIP = 0.5e4;\n\nuint256 constant RAY = 1e27;\nuint256 constant HALF_RAY = 0.5e27;\n\nuint256 constant BIP_RAY_RATIO = 1e23;\n\nuint256 constant SECONDS_IN_365_DAYS = 365 days;\n\nlibrary MathUtils {\n  /// @dev The multiply-divide operation failed, either due to a\n  /// multiplication overflow, or a division by a zero.\n  error MulDivFailed();\n\n  using MathUtils for uint256;\n\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   *\n   * @param rateBip The interest rate, in bips\n   * @param timeDelta The time elapsed since the last interest accrual\n   * @return result The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterestFromBips(\n    uint256 rateBip,\n    uint256 timeDelta\n  ) internal pure returns (uint256 result) {\n    uint256 rate = rateBip.bipToRay();\n    uint256 accumulatedInterestRay = rate * timeDelta;\n    unchecked {\n      return accumulatedInterestRay / SECONDS_IN_365_DAYS;\n    }\n  }\n\n  /**\n   * @dev Return the smaller of `a` and `b`\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = ternary(a < b, a, b);\n  }\n\n  /**\n   * @dev Return the larger of `a` and `b`.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = ternary(a < b, b, a);\n  }\n\n  /**\n   * @dev Saturation subtraction. Subtract `b` from `a` and return the result\n   *      if it is positive or zero if it underflows.\n   */\n  function satSub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // (a > b) * (a - b)\n      // If a-b underflows, the product will be zero\n      c := mul(gt(a, b), sub(a, b))\n    }\n  }\n\n  /**\n   * @dev Saturation addition. Add `a` to `b` and return the result\n   *      if it is less than `maxValue` or `maxValue` if it overflows.\n   */\n  function satAdd(uint256 a, uint256 b, uint256 maxValue) internal pure returns (uint256 c) {\n    unchecked {\n      c = a + b;\n      return ternary(c < maxValue, c, maxValue);\n    }\n  }\n\n  /**\n   * @dev Return `valueIfTrue` if `condition` is true and `valueIfFalse` if it is false.\n   *      Equivalent to `condition ? valueIfTrue : valueIfFalse`\n   */\n  function ternary(\n    bool condition,\n    uint256 valueIfTrue,\n    uint256 valueIfFalse\n  ) internal pure returns (uint256 c) {\n    assembly {\n      c := add(valueIfFalse, mul(condition, sub(valueIfTrue, valueIfFalse)))\n    }\n  }\n\n  /**\n   * @dev Multiplies two bip, rounding half up to the nearest bip\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function bipMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b == 0 || a <= (type(uint256).max - HALF_BIP) / b)`\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_BIP), b))))) {\n        // Store the Panic error signature.\n        mstore(0, Panic_ErrorSelector)\n        // Store the arithmetic (0x11) panic code.\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, b), HALF_BIP), BIP)\n    }\n  }\n\n  /**\n   * @dev Divides two bip, rounding half up to the nearest bip\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function bipDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b != 0 && a <= (type(uint256).max - b/2) / BIP)`\n      if or(iszero(b), gt(a, div(sub(not(0), div(b, 2)), BIP))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, BIP), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Converts bip up to ray\n   */\n  function bipToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/BIP_RAY_RATIO == a\n    assembly {\n      b := mul(a, BIP_RAY_RATIO)\n      // equivalent to `require((b = a * BIP_RAY_RATIO) / BIP_RAY_RATIO == a )\n      if iszero(eq(div(b, BIP_RAY_RATIO), a)) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n    }\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b == 0 || a <= (type(uint256).max - HALF_RAY) / b)`\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @dev Divide two ray, rounding half up to the nearest ray\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b != 0 && a <= (type(uint256).max - halfB) / RAY)`\n      if or(iszero(b), gt(a, div(sub(not(0), div(b, 2)), RAY))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Returns `floor(x * y / d)`.\n   *      Reverts if `x * y` overflows, or `d` is zero.\n   * @custom:author solady/src/utils/FixedPointMathLib.sol\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n    assembly {\n      // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n        // Store the function selector of `MulDivFailed()`.\n        mstore(0x00, 0xad251c27)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := div(mul(x, y), d)\n    }\n  }\n\n  /**\n   * @dev Returns `ceil(x * y / d)`.\n   *      Reverts if `x * y` overflows, or `d` is zero.\n   * @custom:author solady/src/utils/FixedPointMathLib.sol\n   */\n  function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n    assembly {\n      // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n        // Store the function selector of `MulDivFailed()`.\n        mstore(0x00, 0xad251c27)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n    }\n  }\n}\n"
    },
    "src/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\n/// @dev Selector for `error NoReentrantCalls()`\nuint256 constant NoReentrantCalls_ErrorSelector = 0x7fa8a987;\n\nuint256 constant _REENTRANCY_GUARD_SLOT = 0x929eee14;\n\n/**\n * @title ReentrancyGuard\n * @author d1ll0n\n * @notice Changes from original:\n *   - Removed the checks for whether tstore is supported.\n * @author Modified from Seaport contract by 0age (https://github.com/ProjectOpenSea/seaport-1.6)\n *\n * @notice ReentrancyGuard contains a transient storage variable and related\n *         functionality for protecting against reentrancy.\n */\ncontract ReentrancyGuard {\n  /**\n   * @dev Revert with an error when a caller attempts to reenter a protected function.\n   *\n   *      Note: Only defined for the sake of the interface and readability - the\n   *      definition is not directly referenced in the contract code.\n   */\n  error NoReentrantCalls();\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n\n  /**\n   * @dev Reentrancy guard for state-changing functions.\n   *      Reverts if the reentrancy guard is currently set; otherwise, sets\n   *      the reentrancy guard, executes the function body, then clears the\n   *      reentrancy guard.\n   */\n  modifier nonReentrant() {\n    _setReentrancyGuard();\n    _;\n    _clearReentrancyGuard();\n  }\n\n  /**\n   * @dev Reentrancy guard for view functions.\n   *      Reverts if the reentrancy guard is currently set.\n   */\n  modifier nonReentrantView() {\n    _assertNonReentrant();\n    _;\n  }\n\n  /**\n   * @dev Internal function to ensure that a sentinel value for the reentrancy\n   *      guard is not currently set and, if not, to set a sentinel value for\n   *      the reentrancy guard.\n   */\n  function _setReentrancyGuard() internal {\n    assembly {\n      // Retrieve the current value of the reentrancy guard slot.\n      let _reentrancyGuard := tload(_REENTRANCY_GUARD_SLOT)\n\n      // Ensure that the reentrancy guard is not already set.\n      // Equivalent to `if (_reentrancyGuard != _NOT_ENTERED) revert NoReentrantCalls();`\n      if _reentrancyGuard {\n        mstore(0, NoReentrantCalls_ErrorSelector)\n        revert(0x1c, 0x04)\n      }\n\n      // Set the reentrancy guard.\n      // Equivalent to `_reentrancyGuard = _ENTERED;`\n      tstore(_REENTRANCY_GUARD_SLOT, _ENTERED)\n    }\n  }\n\n  /**\n   * @dev Internal function to unset the reentrancy guard sentinel value.\n   */\n  function _clearReentrancyGuard() internal {\n    assembly {\n      // Equivalent to `_reentrancyGuard = _NOT_ENTERED;`\n      tstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED)\n    }\n  }\n\n  /**\n   * @dev Internal view function to ensure that a sentinel value for the\n   *         reentrancy guard is not currently set.\n   */\n  function _assertNonReentrant() internal view {\n    assembly {\n      // Ensure that the reentrancy guard is not currently set.\n      // Equivalent to `if (_reentrancyGuard != _NOT_ENTERED) revert NoReentrantCalls();`\n      if tload(_REENTRANCY_GUARD_SLOT) {\n        mstore(0, NoReentrantCalls_ErrorSelector)\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n}\n"
    },
    "src/interfaces/WildcatStructsAndEnums.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport { MarketState } from '../libraries/MarketState.sol';\n\nimport { HooksConfig } from '../types/HooksConfig.sol';\n\nstruct MarketParameters {\n  address asset;\n  uint8 decimals;\n  bytes32 packedNameWord0;\n  bytes32 packedNameWord1;\n  bytes32 packedSymbolWord0;\n  bytes32 packedSymbolWord1;\n  address borrower;\n  address feeRecipient;\n  address sentinel;\n  uint128 maxTotalSupply;\n  uint16 protocolFeeBips;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  address archController;\n  address sphereXEngine;\n  HooksConfig hooks;\n}\n\nstruct DeployMarketInputs {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  HooksConfig hooks;\n}\n\nstruct MarketControllerParameters {\n  address archController;\n  address borrower;\n  address sentinel;\n  address marketInitCodeStorage;\n  uint256 marketInitCodeHash;\n  uint32 minimumDelinquencyGracePeriod;\n  uint32 maximumDelinquencyGracePeriod;\n  uint16 minimumReserveRatioBips;\n  uint16 maximumReserveRatioBips;\n  uint16 minimumDelinquencyFeeBips;\n  uint16 maximumDelinquencyFeeBips;\n  uint32 minimumWithdrawalBatchDuration;\n  uint32 maximumWithdrawalBatchDuration;\n  uint16 minimumAnnualInterestBips;\n  uint16 maximumAnnualInterestBips;\n  address sphereXEngine;\n}\n\nstruct ProtocolFeeConfiguration {\n  address feeRecipient;\n  address originationFeeAsset;\n  uint80 originationFeeAmount;\n  uint16 protocolFeeBips;\n}\n\nstruct MarketParameterConstraints {\n  uint32 minimumDelinquencyGracePeriod;\n  uint32 maximumDelinquencyGracePeriod;\n  uint16 minimumReserveRatioBips;\n  uint16 maximumReserveRatioBips;\n  uint16 minimumDelinquencyFeeBips;\n  uint16 maximumDelinquencyFeeBips;\n  uint32 minimumWithdrawalBatchDuration;\n  uint32 maximumWithdrawalBatchDuration;\n  uint16 minimumAnnualInterestBips;\n  uint16 maximumAnnualInterestBips;\n}\n"
    },
    "src/access/IHooks.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport '../types/HooksConfig.sol';\nimport '../libraries/MarketState.sol';\nimport '../interfaces/WildcatStructsAndEnums.sol';\n\nabstract contract IHooks {\n  error CallerNotFactory();\n\n  address public immutable factory;\n\n  constructor() {\n    factory = msg.sender;\n  }\n\n  /// @dev Returns the version string of the hooks contract.\n  ///      Used to determine what the contract does and how `extraData` is interpreted.\n  function version() external view virtual returns (string memory);\n\n  /// @dev Returns the HooksDeploymentConfig type which contains the sets\n  ///      of optional and required hooks that this contract implements.\n  function config() external view virtual returns (HooksDeploymentConfig);\n\n  function onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata extraData\n  ) external {\n    if (msg.sender != factory) revert CallerNotFactory();\n    _onCreateMarket(deployer, marketAddress, parameters, extraData);\n  }\n\n  function _onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata extraData\n  ) internal virtual;\n\n  function onDeposit(\n    address lender,\n    uint256 scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onQueueWithdrawal(\n    address lender,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onExecuteWithdrawal(\n    address lender,\n    uint128 normalizedAmountWithdrawn,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onTransfer(\n    address caller,\n    address from,\n    address to,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onBorrow(\n    uint normalizedAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onRepay(\n    uint normalizedAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onCloseMarket(\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onAssetsSentToEscrow(\n    address lender,\n    address asset,\n    address escrow,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onSetMaxTotalSupply(\n    uint256 maxTotalSupply,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips);\n}\n"
    },
    "src/IHooksFactory.sol": {
      "content": "import './access/IHooks.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\n\nstruct HooksTemplate {\n  /// @dev Asset used to pay origination fee\n  address originationFeeAsset;\n  /// @dev Amount of `originationFeeAsset` paid to deploy a new market using\n  ///      an instance of this template.\n  uint80 originationFeeAmount;\n  /// @dev Basis points paid on interest for markets deployed using hooks\n  ///      based on this template\n  uint16 protocolFeeBips;\n  /// @dev Whether the template exists\n  bool exists;\n  /// @dev Whether the template is enabled\n  bool enabled;\n  /// @dev Index of the template address in the array of hooks templates\n  uint24 index;\n  /// @dev Address to pay origination and interest fees\n  address feeRecipient;\n  /// @dev Name of the template\n  string name;\n}\n\ninterface IHooksFactoryEventsAndErrors {\n  error NotApprovedBorrower();\n  error HooksTemplateNotFound();\n  error HooksTemplateNotAvailable();\n  error HooksTemplateAlreadyExists();\n  error DeploymentFailed();\n  error HooksInstanceNotFound();\n  error CallerNotArchControllerOwner();\n  error InvalidFeeConfiguration();\n  error SaltDoesNotContainSender();\n  error MarketAlreadyExists();\n  error NameOrSymbolTooLong();\n  error AssetBlacklisted();\n\n  event HooksInstanceDeployed(address hooksInstance, address hooksTemplate);\n  event HooksTemplateAdded(\n    address hooksTemplate,\n    string name,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  );\n  event HooksTemplateDisabled(address hooksTemplate);\n  event HooksTemplateFeesUpdated(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  );\n\n  event MarketDeployed(\n    address indexed market,\n    string name,\n    string symbol,\n    address asset,\n    uint256 maxTotalSupply,\n    uint256 annualInterestBips,\n    uint256 delinquencyFeeBips,\n    uint256 withdrawalBatchDuration,\n    uint256 reserveRatioBips,\n    uint256 delinquencyGracePeriod,\n    HooksConfig hooks\n  );\n}\n\ninterface IHooksFactory is IHooksFactoryEventsAndErrors {\n  function archController() external view returns (address);\n\n  function sanctionsSentinel() external view returns (address);\n\n  function marketInitCodeStorage() external view returns (address);\n\n  function marketInitCodeHash() external view returns (uint256);\n\n  /// @dev Set-up function to register the factory as a controller with the arch-controller.\n  ///      This enables the factory to register new markets.\n  function registerWithArchController() external;\n\n  // ========================================================================== //\n  //                               Hooks Templates                              //\n  // ========================================================================== //\n\n  /// @dev Add a hooks template that stores the initcode for the template.\n  ///\n  ///      On success:\n  ///      - Emits `HooksTemplateAdded` on success.\n  ///      - Adds the template to the list of templates.\n  ///      - Creates `HooksTemplate` struct with the given parameters mapped to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not the owner of the arch-controller.\n  ///      - The template already exists.\n  ///      - The fee settings are invalid.\n  function addHooksTemplate(\n    address hooksTemplate,\n    string calldata name,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external;\n\n  /// @dev Update the fees for a hooks template.\n  ///\n  ///      On success:\n  ///      - Emits `HooksTemplateFeesUpdated` on success.\n  ///      - Updates the fees for the `HooksTemplate` struct mapped to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not the owner of the arch-controller.\n  ///      - The template does not exist.\n  ///      - The fee settings are invalid.\n  function updateHooksTemplateFees(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external;\n\n  /// @dev Disable a hooks template.\n  ///\n  ///      On success:\n  ///      - Emits `HooksTemplateDisabled` on success.\n  ///      - Disables the `HooksTemplate` struct mapped to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not the owner of the arch-controller.\n  ///      - The template does not exist.\n  function disableHooksTemplate(address hooksTemplate) external;\n\n  /// @dev Get the name and fee configuration for an approved hooks template.\n  function getHooksTemplateDetails(\n    address hooksTemplate\n  ) external view returns (HooksTemplate memory);\n\n  /// @dev Check if a hooks template is approved.\n  function isHooksTemplate(address hooksTemplate) external view returns (bool);\n\n  /// @dev Get the list of approved hooks templates.\n  function getHooksTemplates() external view returns (address[] memory);\n\n  // ========================================================================== //\n  //                               Hooks Instances                              //\n  // ========================================================================== //\n\n  /// @dev Deploy a hooks instance for an approved template with constructor args.\n  ///\n  ///      On success:\n  ///      - Emits `HooksInstanceDeployed`.\n  ///      - Deploys a new hooks instance with the given templates and constructor args.\n  ///      - Maps the hooks instance to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not an approved borrower.\n  ///      - The template does not exist.\n  ///      - The template is not enabled.\n  ///      - The deployment fails.\n  function deployHooksInstance(\n    address hooksTemplate,\n    bytes calldata constructorArgs\n  ) external returns (address hooksDeployment);\n\n  /// @dev Check if a hooks instance was deployed by the factory.\n  function isHooksInstance(address hooks) external view returns (bool);\n\n  /// @dev Get the template that was used to deploy a hooks instance.\n  function getHooksTemplateForInstance(address hooks) external view returns (address);\n\n  // ========================================================================== //\n  //                                   Markets                                  //\n  // ========================================================================== //\n\n  /// @dev Get the temporarily stored market parameters for a market that is\n  ///      currently being deployed.\n  function getMarketParameters() external view returns (MarketParameters memory parameters);\n\n  /// @dev Deploy a market with an existing hooks deployment (in `parameters.hooks`)\n  ///\n  ///      On success:\n  ///      - Pays the origination fee (if applicable).\n  ///      - Calls `onDeployMarket` on the hooks contract.\n  ///      - Deploys a new market with the given parameters.\n  ///      - Emits `MarketDeployed`.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not an approved borrower.\n  ///      - The hooks instance does not exist.\n  ///      - Payment of origination fee fails.\n  ///      - The deployment fails.\n  ///      - The call to `onDeployMarket` fails.\n  function deployMarket(\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt\n  ) external returns (address market);\n\n  /// @dev Deploy a hooks instance for an approved template,then deploy a new market with that\n  ///      instance as its hooks contract.\n  ///      Will call `onCreateMarket` on `parameters.hooks`.\n  function deployMarketAndHooks(\n    address hooksTemplate,\n    bytes calldata hooksConstructorArgs,\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt\n  ) external returns (address market, address hooks);\n\n  function computeMarketAddress(bytes32 salt) external view returns (address);\n}\n"
    },
    "src/types/TransientBytesArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.25;\nimport { Panic_ErrorSelector, Panic_ErrorCodePointer, Panic_InvalidStorageByteArray, Error_SelectorPointer, Panic_ErrorLength } from '../libraries/Errors.sol';\n\ntype TransientBytesArray is uint256;\n\nusing LibTransientBytesArray for TransientBytesArray global;\n\nlibrary LibTransientBytesArray {\n  /**\n   * @dev Decode a dynamic bytes array from transient storage.\n   * @param transientSlot Slot for the dynamic bytes array in transient storage\n   * @param memoryPointer Pointer to the memory location to write the decoded array to\n   * @return endPointer Pointer to the end of the decoded array\n   */\n  function readToPointer(\n    TransientBytesArray transientSlot,\n    uint256 memoryPointer\n  ) internal view returns (uint256 endPointer) {\n    assembly {\n      function extractByteArrayLength(data) -> length {\n        length := div(data, 2)\n        let outOfPlaceEncoding := and(data, 1)\n        if iszero(outOfPlaceEncoding) {\n          length := and(length, 0x7f)\n        }\n\n        if eq(outOfPlaceEncoding, lt(length, 32)) {\n          // Store the Panic error signature.\n          mstore(0, Panic_ErrorSelector)\n          // Store the arithmetic (0x11) panic code.\n          mstore(Panic_ErrorCodePointer, Panic_InvalidStorageByteArray)\n          // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x22))\n          revert(Error_SelectorPointer, Panic_ErrorLength)\n        }\n      }\n      let slotValue := tload(transientSlot)\n      let length := extractByteArrayLength(slotValue)\n      mstore(memoryPointer, length)\n      memoryPointer := add(memoryPointer, 0x20)\n      switch and(slotValue, 1)\n      case 0 {\n        // short byte array\n        let value := and(slotValue, not(0xff))\n        mstore(memoryPointer, value)\n        endPointer := add(memoryPointer, 0x20)\n      }\n      case 1 {\n        // long byte array\n        mstore(0, transientSlot)\n        // Calculate the slot of the data portion of the array\n        let dataTSlot := keccak256(0, 0x20)\n        let i := 0\n        for {\n\n        } lt(i, length) {\n          i := add(i, 0x20)\n        } {\n          mstore(add(memoryPointer, i), tload(dataTSlot))\n          dataTSlot := add(dataTSlot, 1)\n        }\n        endPointer := add(memoryPointer, i)\n      }\n    }\n  }\n\n  function read(TransientBytesArray transientSlot) internal view returns (bytes memory data) {\n    uint256 dataPointer;\n    assembly {\n      dataPointer := mload(0x40)\n      data := dataPointer\n      mstore(data, 0)\n    }\n    uint256 endPointer = readToPointer(transientSlot, dataPointer);\n    assembly {\n      mstore(0x40, endPointer)\n    }\n  }\n\n  /**\n   * @dev Write a dynamic bytes array to transient storage.\n   * @param transientSlot Slot for the dynamic bytes array in transient storage\n   * @param memoryPointer Pointer to the memory location of the array to write\n   */\n  function write(TransientBytesArray transientSlot, bytes memory memoryPointer) internal {\n    assembly {\n      let length := mload(memoryPointer)\n      memoryPointer := add(memoryPointer, 0x20)\n      switch lt(length, 32)\n      case 0 {\n        // For long byte arrays, the length slot holds (length * 2 + 1)\n        tstore(transientSlot, add(1, mul(2, length)))\n        // Calculate the slot of the data portion of the array\n        mstore(0, transientSlot)\n        let dataTSlot := keccak256(0, 0x20)\n        let i := 0\n        for {\n\n        } lt(i, length) {\n          i := add(i, 0x20)\n        } {\n          tstore(dataTSlot, mload(add(memoryPointer, i)))\n          dataTSlot := add(dataTSlot, 1)\n        }\n      }\n      case 1 {\n        // For short byte arrays, the first 31 bytes are the data and the last byte is (length * 2).\n        let lengthByte := mul(2, length)\n        let data := mload(memoryPointer)\n        tstore(transientSlot, or(data, lengthByte))\n      }\n    }\n  }\n\n  function setEmpty(TransientBytesArray transientSlot) internal {\n    assembly {\n      tstore(transientSlot, 0)\n    }\n  }\n}\n"
    },
    "src/spherex/SphereXProtectedRegisteredBase.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\npragma solidity ^0.8.20;\n\nimport { ISphereXEngine, ModifierLocals } from './ISphereXEngine.sol';\nimport './SphereXProtectedEvents.sol';\nimport './SphereXProtectedErrors.sol';\n\n/**\n * @title Modified version of SphereXProtectedBase for contracts registered\n *        on Wildcat's arch controller.\n *\n * @author Modified from https://github.com/spherex-xyz/spherex-protect-contracts/blob/main/src/SphereXProtectedBase.sol\n *\n * @dev In this version, the WildcatArchController deployment is the SphereX operator.\n *      There is no admin because the arch controller address can not be modified.\n *\n *      All admin functions/events/errors have been removed to reduce contract size.\n *\n *      SphereX engine address validation is delegated to the arch controller.\n */\nabstract contract SphereXProtectedRegisteredBase {\n  // ========================================================================== //\n  //                                  Constants                                 //\n  // ========================================================================== //\n\n  /// @dev Storage slot with the address of the SphereX engine contract.\n  bytes32 private constant SPHEREX_ENGINE_STORAGE_SLOT =\n    bytes32(uint256(keccak256('eip1967.spherex.spherex_engine')) - 1);\n\n  /**\n   * @dev Address of the WildcatArchController deployment.\n   *      The arch controller is able to set the SphereX engine address.\n   *      The inheriting contract must assign this in the constructor.\n   */\n  address internal immutable _archController;\n\n  // ========================================================================== //\n  //                                 Initializer                                //\n  // ========================================================================== //\n\n  /**\n   * @dev Initializes the SphereXEngine and emits events for the initial\n   *      engine and operator (arch controller).\n   */\n  function __SphereXProtectedRegisteredBase_init(address engine) internal virtual {\n    emit_ChangedSpherexOperator(address(0), _archController);\n    _setAddress(SPHEREX_ENGINE_STORAGE_SLOT, engine);\n    emit_ChangedSpherexEngineAddress(address(0), engine);\n  }\n\n  // ========================================================================== //\n  //                              Events and Errors                             //\n  // ========================================================================== //\n\n  error SphereXOperatorRequired();\n\n  event ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin);\n  event ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress);\n\n  // ========================================================================== //\n  //                               Local Modifiers                              //\n  // ========================================================================== //\n\n  modifier spherexOnlyOperator() {\n    if (msg.sender != _archController) {\n      revert_SphereXOperatorRequired();\n    }\n    _;\n  }\n\n  modifier returnsIfNotActivatedPre(ModifierLocals memory locals) {\n    locals.engine = sphereXEngine();\n    if (locals.engine == address(0)) {\n      return;\n    }\n\n    _;\n  }\n\n  modifier returnsIfNotActivatedPost(ModifierLocals memory locals) {\n    if (locals.engine == address(0)) {\n      return;\n    }\n\n    _;\n  }\n\n  // ========================================================================== //\n  //                                 Management                                 //\n  // ========================================================================== //\n\n  /// @dev Returns the current operator address.\n  function sphereXOperator() public view returns (address) {\n    return _archController;\n  }\n\n  /// @dev Returns the current engine address.\n  function sphereXEngine() public view returns (address) {\n    return _getAddress(SPHEREX_ENGINE_STORAGE_SLOT);\n  }\n\n  /**\n   * @dev  Change the address of the SphereX engine.\n   *\n   *       This is also used to enable SphereX protection, which is disabled\n   *       when the engine address is 0.\n   *\n   * Note: The new engine is not validated as it would be in `SphereXProtectedBase`\n   *       because the operator is the arch controller, which validates the engine\n   *       address prior to updating it here.\n   */\n  function changeSphereXEngine(address newSphereXEngine) external spherexOnlyOperator {\n    address oldEngine = _getAddress(SPHEREX_ENGINE_STORAGE_SLOT);\n    _setAddress(SPHEREX_ENGINE_STORAGE_SLOT, newSphereXEngine);\n    emit_ChangedSpherexEngineAddress(oldEngine, newSphereXEngine);\n  }\n\n  // ========================================================================== //\n  //                                    Hooks                                   //\n  // ========================================================================== //\n\n  /**\n   * @dev Wrapper for `_getStorageSlotsAndPreparePostCalldata` that returns\n   *      a `uint256` pointer to `locals` rather than the struct itself.\n   *\n   *      Declaring a return parameter for a struct will always zero and\n   *      allocate memory for every field in the struct. If the parameter\n   *      is always reassigned, the gas and memory used on this are wasted.\n   *\n   *      Using a `uint256` pointer instead of a struct declaration avoids\n   *      this waste while being functionally identical.\n   */\n  function _sphereXValidateExternalPre() internal returns (uint256 localsPointer) {\n    return _castFunctionToPointerOutput(_getStorageSlotsAndPreparePostCalldata)(_getSelector());\n  }\n\n  /**\n   * @dev Internal function for engine communication. We use it to reduce contract size.\n   *      Should be called before the code of an external function.\n   *\n   *      Queries `storageSlots` from `sphereXValidatePre` on the engine and writes\n   *      the result to `locals.storageSlots`, then caches the current storage values\n   *      for those slots in `locals.valuesBefore`.\n   *\n   *      Also allocates memory for the calldata of the future call to `sphereXValidatePost`\n   *      and initializes every value in the calldata except for `gas` and `valuesAfter` data.\n   *\n   * @param num function identifier\n   */\n  function _getStorageSlotsAndPreparePostCalldata(\n    int256 num\n  ) internal returnsIfNotActivatedPre(locals) returns (ModifierLocals memory locals) {\n    assembly {\n      // Read engine from `locals.engine` - this is filled by `returnsIfNotActivatedPre`\n      let engineAddress := mload(add(locals, 0x60))\n\n      // Get free memory pointer - this will be used for the calldata\n      // to `sphereXValidatePre` and then reused for both `storageSlots`\n      // and the future calldata to `sphereXValidatePost`\n      let pointer := mload(0x40)\n\n      // Call `sphereXValidatePre(num, msg.sender, msg.data)`\n      mstore(pointer, 0x8925ca5a)\n      mstore(add(pointer, 0x20), num)\n      mstore(add(pointer, 0x40), caller())\n      mstore(add(pointer, 0x60), 0x60)\n      mstore(add(pointer, 0x80), calldatasize())\n      calldatacopy(add(pointer, 0xa0), 0, calldatasize())\n      let size := add(0xc4, calldatasize())\n\n      if iszero(\n        and(eq(mload(0), 0x20), call(gas(), engineAddress, 0, add(pointer, 28), size, 0, 0x40))\n      ) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      let length := mload(0x20)\n\n      // Set up the memory after the allocation `locals` struct as:\n      // [0x00:0x20]: `storageSlots.length`\n      // [0x20:0x20+(length * 0x20)]: `storageSlots` data\n      // [0x20+(length*0x20):]: calldata for `sphereXValidatePost`\n\n      // The layout for the `sphereXValidatePost` calldata is:\n      // [0x00:0x20]: num\n      // [0x20:0x40]: gas\n      // [0x40:0x60]: valuesBefore offset (0x80)\n      // [0x60:0x80]: valuesAfter offset (0xa0 + (0x20 * length))\n      // [0x80:0xa0]: valuesBefore length (0xa0 + (0x20 * length))\n      // [0xa0:0xa0+(0x20*length)]: valuesBefore data\n      // [0xa0+(0x20*length):0xc0+(0x20*length)] valuesAfter length\n      // [0xc0+(0x20*length):0xc0+(0x40*length)]: valuesAfter data\n      //\n      // size of calldata: 0xc0 + (0x40 * length)\n      //\n      // size of allocation: 0xe0 + (0x60 * length)\n\n      // Calculate size of array data (excluding length): 32 * length\n      let arrayDataSize := shl(5, length)\n\n      // Finalize memory allocation with space for `storageSlots` and\n      // the calldata for `sphereXValidatePost`.\n      mstore(0x40, add(pointer, add(0xe0, mul(arrayDataSize, 3))))\n\n      // Copy `storageSlots` from returndata to the start of the allocated\n      // memory buffer and write the pointer to `locals.storageSlots`\n      returndatacopy(pointer, 0x20, add(arrayDataSize, 0x20))\n      mstore(locals, pointer)\n\n      // Get pointer to future calldata.\n      // Add `32 + arrayDataSize` to skip the allocation for `locals.storageSlots`\n      // @todo *could* put `valuesBefore` before `storageSlots` and reuse\n      // the `storageSlots` buffer for `valuesAfter`\n      let calldataPointer := add(pointer, add(arrayDataSize, 0x20))\n\n      // Write `-num` to calldata\n      mstore(calldataPointer, sub(0, num))\n\n      // Write `valuesBefore` offset to calldata\n      mstore(add(calldataPointer, 0x40), 0x80)\n\n      // Write `locals.valuesBefore` pointer\n      mstore(add(locals, 0x20), add(calldataPointer, 0x80))\n\n      // Write `valuesAfter` offset to calldata\n      mstore(add(calldataPointer, 0x60), add(0xa0, arrayDataSize))\n\n      // Write `gasleft()` to `locals.gas`\n      mstore(add(locals, 0x40), gas())\n    }\n    _readStorageTo(locals.storageSlots, locals.valuesBefore);\n  }\n\n  /**\n   * @dev Wrapper for `_callSphereXValidatePost` that takes a pointer\n   *      instead of a struct.\n   */\n  function _sphereXValidateExternalPost(uint256 locals) internal {\n    _castFunctionToPointerInput(_callSphereXValidatePost)(locals);\n  }\n\n  function _callSphereXValidatePost(\n    ModifierLocals memory locals\n  ) internal returnsIfNotActivatedPost(locals) {\n    uint256 length;\n    bytes32[] memory storageSlots;\n    bytes32[] memory valuesAfter;\n    assembly {\n      storageSlots := mload(locals)\n      length := mload(storageSlots)\n      valuesAfter := add(storageSlots, add(0xc0, shl(6, length)))\n    }\n    _readStorageTo(storageSlots, valuesAfter);\n    assembly {\n      let sphereXEngineAddress := mload(add(locals, 0x60))\n      let arrayDataSize := shl(5, length)\n      let calldataSize := add(0xc4, shl(1, arrayDataSize))\n\n      let calldataPointer := add(storageSlots, add(arrayDataSize, 0x20))\n      let gasDiff := sub(mload(add(locals, 0x40)), gas())\n      mstore(add(calldataPointer, 0x20), gasDiff)\n      let slotBefore := sub(calldataPointer, 32)\n      let slotBeforeCache := mload(slotBefore)\n      mstore(slotBefore, 0xf0bd9468)\n      if iszero(call(gas(), sphereXEngineAddress, 0, add(slotBefore, 28), calldataSize, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      mstore(slotBefore, slotBeforeCache)\n    }\n  }\n\n  /// @dev Returns the function selector from the current calldata.\n  function _getSelector() internal pure returns (int256 selector) {\n    assembly {\n      selector := shr(224, calldataload(0))\n    }\n  }\n\n  /// @dev Modifier to be incorporated in all external protected non-view functions\n  modifier sphereXGuardExternal() {\n    uint256 localsPointer = _sphereXValidateExternalPre();\n    _;\n    _sphereXValidateExternalPost(localsPointer);\n  }\n\n  // ========================================================================== //\n  //                          Internal Storage Helpers                          //\n  // ========================================================================== //\n\n  /// @dev Stores an address in an arbitrary slot\n  function _setAddress(bytes32 slot, address newAddress) internal {\n    assembly {\n      sstore(slot, newAddress)\n    }\n  }\n\n  /// @dev Returns an address from an arbitrary slot.\n  function _getAddress(bytes32 slot) internal view returns (address addr) {\n    assembly {\n      addr := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Internal function that reads values from given storage slots\n   *      and writes them to a particular memory location.\n   *\n   * @param storageSlots array of storage slots to read\n   * @param values array of values to write values to\n   */\n  function _readStorageTo(bytes32[] memory storageSlots, bytes32[] memory values) internal view {\n    assembly {\n      let length := mload(storageSlots)\n      let arrayDataSize := shl(5, length)\n      mstore(values, length)\n      let nextSlotPointer := add(storageSlots, 0x20)\n      let nextElementPointer := add(values, 0x20)\n      let endPointer := add(nextElementPointer, shl(5, length))\n      for {\n\n      } lt(nextElementPointer, endPointer) {\n\n      } {\n        mstore(nextElementPointer, sload(mload(nextSlotPointer)))\n        nextElementPointer := add(nextElementPointer, 0x20)\n        nextSlotPointer := add(nextSlotPointer, 0x20)\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                             Function Type Casts                            //\n  // ========================================================================== //\n\n  function _castFunctionToPointerInput(\n    function(ModifierLocals memory) internal fnIn\n  ) internal pure returns (function(uint256) internal fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n\n  function _castFunctionToPointerOutput(\n    function(int256) internal returns (ModifierLocals memory) fnIn\n  ) internal pure returns (function(int256) internal returns (uint256) fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n}\n"
    },
    "src/libraries/StringQuery.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport { LibBit } from 'solady/utils/LibBit.sol';\n\nusing LibBit for uint256;\n\nuint256 constant OnlyFullWordMask = 0xffffffe0;\n\nfunction bytes32ToString(bytes32 value) pure returns (string memory str) {\n  uint256 size;\n  unchecked {\n    uint256 sizeInBits = 255 - uint256(value).ffs();\n    size = (sizeInBits + 7) / 8;\n  }\n  assembly {\n    str := mload(0x40)\n    mstore(0x40, add(str, 0x40))\n    mstore(str, size)\n    mstore(add(str, 0x20), value)\n  }\n}\n\nfunction queryStringOrBytes32AsString(\n  address target,\n  uint256 leftPaddedFunctionSelector,\n  uint256 leftPaddedGenericErrorSelector\n) view returns (string memory str) {\n  bool isBytes32;\n  assembly {\n    mstore(0, leftPaddedFunctionSelector)\n    let status := staticcall(gas(), target, 0x1c, 0x04, 0, 0)\n    isBytes32 := eq(returndatasize(), 0x20)\n    // If call fails or function returns invalid data, revert.\n    // Strings are always right padded to full words - if the returndata\n    // is not 32 bytes (string encoded as bytes32) or >95 bytes (minimum abi\n    // encoded string) it is an invalid string.\n    if or(iszero(status), iszero(or(isBytes32, gt(returndatasize(), 0x5f)))) {\n      // Check if call failed\n      if iszero(status) {\n        // Check if any revert data was given\n        if returndatasize() {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n        // If not, throw a generic error\n        mstore(0, leftPaddedGenericErrorSelector)\n        revert(0x1c, 0x04)\n      }\n      // If the returndata is the wrong size, `revert InvalidReturnDataString()`\n      mstore(0, 0x4cb9c000)\n      revert(0x1c, 0x04)\n    }\n  }\n  if (isBytes32) {\n    uint256 value;\n    assembly {\n      returndatacopy(0x00, 0x00, 0x20)\n      value := mload(0)\n    }\n    uint256 size;\n    unchecked {\n      uint256 sizeInBits = 255 - value.ffs();\n      size = (sizeInBits + 7) / 8;\n    }\n    assembly {\n      str := mload(0x40)\n      mstore(0x40, add(str, 0x40))\n      mstore(str, size)\n      mstore(add(str, 0x20), value)\n    }\n  } else {\n    // If returndata is a string, copy the length and value\n    assembly {\n      str := mload(0x40)\n      // Get allocation size for the string including the length and data.\n      // Rounding down returndatasize to nearest word because the returndata\n      // has an extra offset word.\n      let allocSize := and(sub(returndatasize(), 1), OnlyFullWordMask)\n      mstore(0x40, add(str, allocSize))\n      // Copy returndata after the offset\n      returndatacopy(str, 0x20, sub(returndatasize(), 0x20))\n      let length := mload(str)\n      // Check if the length matches the returndatasize.\n      // The encoded string should have the string length rounded up to the nearest word\n      // as well as two words for length and offset.\n      let expectedReturndataSize := add(allocSize, 0x20)\n      if xor(returndatasize(), expectedReturndataSize) {\n        mstore(0, 0x4cb9c000)\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n}\n"
    },
    "src/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nuint256 constant Panic_CompilerPanic = 0x00;\nuint256 constant Panic_AssertFalse = 0x01;\nuint256 constant Panic_Arithmetic = 0x11;\nuint256 constant Panic_DivideByZero = 0x12;\nuint256 constant Panic_InvalidEnumValue = 0x21;\nuint256 constant Panic_InvalidStorageByteArray = 0x22;\nuint256 constant Panic_EmptyArrayPop = 0x31;\nuint256 constant Panic_ArrayOutOfBounds = 0x32;\nuint256 constant Panic_MemoryTooLarge = 0x41;\nuint256 constant Panic_UninitializedFunctionPointer = 0x51;\n\nuint256 constant Panic_ErrorSelector = 0x4e487b71;\nuint256 constant Panic_ErrorCodePointer = 0x20;\nuint256 constant Panic_ErrorLength = 0x24;\nuint256 constant Error_SelectorPointer = 0x1c;\n\n/**\n * @dev Reverts with the given error selector.\n * @param errorSelector The left-aligned error selector.\n */\nfunction revertWithSelector(bytes4 errorSelector) pure {\n  assembly {\n    mstore(0, errorSelector)\n    revert(0, 4)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector.\n * @param errorSelector The left-padded error selector.\n */\nfunction revertWithSelector(uint256 errorSelector) pure {\n  assembly {\n    mstore(0, errorSelector)\n    revert(Error_SelectorPointer, 4)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector and argument.\n * @param errorSelector The left-aligned error selector.\n * @param argument The argument to the error.\n */\nfunction revertWithSelectorAndArgument(bytes4 errorSelector, uint256 argument) pure {\n  assembly {\n    mstore(0, errorSelector)\n    mstore(4, argument)\n    revert(0, 0x24)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector and argument.\n * @param errorSelector The left-padded error selector.\n * @param argument The argument to the error.\n */\nfunction revertWithSelectorAndArgument(uint256 errorSelector, uint256 argument) pure {\n  assembly {\n    mstore(0, errorSelector)\n    mstore(0x20, argument)\n    revert(Error_SelectorPointer, 0x24)\n  }\n}\n"
    },
    "src/libraries/MarketState.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './MathUtils.sol';\nimport './SafeCastLib.sol';\nimport './FeeMath.sol';\n\nusing MarketStateLib for MarketState global;\nusing MarketStateLib for Account global;\nusing FeeMath for MarketState global;\n\nstruct MarketState {\n  bool isClosed;\n  uint128 maxTotalSupply;\n  uint128 accruedProtocolFees;\n  // Underlying assets reserved for withdrawals which have been paid\n  // by the borrower but not yet executed.\n  uint128 normalizedUnclaimedWithdrawals;\n  // Scaled token supply (divided by scaleFactor)\n  uint104 scaledTotalSupply;\n  // Scaled token amount in withdrawal batches that have not been\n  // paid by borrower yet.\n  uint104 scaledPendingWithdrawals;\n  uint32 pendingWithdrawalExpiry;\n  // Whether market is currently delinquent (liquidity under requirement)\n  bool isDelinquent;\n  // Seconds borrower has been delinquent\n  uint32 timeDelinquent;\n  // Annual interest rate accrued to lenders, in basis points\n  uint16 annualInterestBips;\n  // Percentage of outstanding balance that must be held in liquid reserves\n  uint16 reserveRatioBips;\n  // Ratio between internal balances and underlying token amounts\n  uint112 scaleFactor;\n  uint32 lastInterestAccruedTimestamp;\n}\n\nstruct Account {\n  uint104 scaledBalance;\n}\n\nlibrary MarketStateLib {\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n\n  /**\n   * @dev Returns the normalized total supply of the market.\n   */\n  function totalSupply(MarketState memory state) internal pure returns (uint256) {\n    return state.normalizeAmount(state.scaledTotalSupply);\n  }\n\n  /**\n   * @dev Returns the maximum amount of tokens that can be deposited without\n   *      reaching the maximum total supply.\n   */\n  function maximumDeposit(MarketState memory state) internal pure returns (uint256) {\n    return uint256(state.maxTotalSupply).satSub(state.totalSupply());\n  }\n\n  /**\n   * @dev Normalize an amount of scaled tokens using the current scale factor.\n   */\n  function normalizeAmount(\n    MarketState memory state,\n    uint256 amount\n  ) internal pure returns (uint256) {\n    return amount.rayMul(state.scaleFactor);\n  }\n\n  /**\n   * @dev Scale an amount of normalized tokens using the current scale factor.\n   */\n  function scaleAmount(MarketState memory state, uint256 amount) internal pure returns (uint256) {\n    return amount.rayDiv(state.scaleFactor);\n  }\n\n  /**\n   * @dev Collateralization requirement is:\n   *      - 100% of all pending (unpaid) withdrawals\n   *      - 100% of all unclaimed (paid) withdrawals\n   *      - reserve ratio times the outstanding debt (supply - pending withdrawals)\n   *      - accrued protocol fees\n   */\n  function liquidityRequired(\n    MarketState memory state\n  ) internal pure returns (uint256 _liquidityRequired) {\n    uint256 scaledWithdrawals = state.scaledPendingWithdrawals;\n    uint256 scaledRequiredReserves = (state.scaledTotalSupply - scaledWithdrawals).bipMul(\n      state.reserveRatioBips\n    ) + scaledWithdrawals;\n    return\n      state.normalizeAmount(scaledRequiredReserves) +\n      state.accruedProtocolFees +\n      state.normalizedUnclaimedWithdrawals;\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets that can be withdrawn\n   *      for protocol fees. The only debts with higher priority are\n   *      processed withdrawals that have not been executed.\n   */\n  function withdrawableProtocolFees(\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint128) {\n    uint256 totalAvailableAssets = totalAssets - state.normalizedUnclaimedWithdrawals;\n    return uint128(MathUtils.min(totalAvailableAssets, state.accruedProtocolFees));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets that can be borrowed.\n   *\n   *      The borrower must maintain sufficient assets in the market to\n   *      cover 100% of pending withdrawals, 100% of previously processed\n   *      withdrawals (before they are executed), and the reserve ratio\n   *      times the outstanding debt (deposits not pending withdrawal).\n   *\n   *      Any underlying assets in the market above this amount can be borrowed.\n   */\n  function borrowableAssets(\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint256) {\n    return totalAssets.satSub(state.liquidityRequired());\n  }\n\n  function hasPendingExpiredBatch(MarketState memory state) internal view returns (bool result) {\n    uint256 expiry = state.pendingWithdrawalExpiry;\n    assembly {\n      // Equivalent to expiry > 0 && expiry < block.timestamp\n      result := and(gt(expiry, 0), gt(timestamp(), expiry))\n    }\n  }\n\n  function totalDebts(MarketState memory state) internal pure returns (uint256) {\n    return\n      state.normalizeAmount(state.scaledTotalSupply) +\n      state.normalizedUnclaimedWithdrawals +\n      state.accruedProtocolFees;\n  }\n}\n"
    },
    "src/types/HooksConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../access/IHooks.sol';\nimport '../libraries/MarketState.sol';\n\ntype HooksConfig is uint256;\n\nHooksConfig constant EmptyHooksConfig = HooksConfig.wrap(0);\n\nusing LibHooksConfig for HooksConfig global;\nusing LibHooksConfig for HooksDeploymentConfig global;\n\n// Type that contains only the flags for a specific hooks contract, with one\n// set of flags for optional hooks and one set of flags for required hooks.\ntype HooksDeploymentConfig is uint256;\n\nfunction encodeHooksDeploymentConfig(\n  HooksConfig optionalFlags,\n  HooksConfig requiredFlags\n) pure returns (HooksDeploymentConfig flags) {\n  assembly {\n    let cleanedOptionalFlags := and(0xffff, shr(0x50, optionalFlags))\n    let cleanedRequiredFlags := and(0xffff0000, shr(0x40, requiredFlags))\n    flags := or(cleanedOptionalFlags, cleanedRequiredFlags)\n  }\n}\n\n// --------------------- Bits after hook activation flag -------------------- //\n\n// Offsets are from the right\n\nuint256 constant Bit_Enabled_Deposit = 95;\nuint256 constant Bit_Enabled_QueueWithdrawal = 94;\nuint256 constant Bit_Enabled_ExecuteWithdrawal = 93;\nuint256 constant Bit_Enabled_Transfer = 92;\nuint256 constant Bit_Enabled_Borrow = 91;\nuint256 constant Bit_Enabled_Repay = 90;\nuint256 constant Bit_Enabled_CloseMarket = 89;\nuint256 constant Bit_Enabled_AssetsSentToEscrow = 88;\nuint256 constant Bit_Enabled_SetMaxTotalSupply = 87;\nuint256 constant Bit_Enabled_SetAnnualInterestAndReserveRatioBips = 86;\n\nuint256 constant MarketStateSize = 0x01a0;\n\nfunction encodeHooksConfig(\n  address hooksAddress,\n  bool useOnDeposit,\n  bool useOnQueueWithdrawal,\n  bool useOnExecuteWithdrawal,\n  bool useOnTransfer,\n  bool useOnBorrow,\n  bool useOnRepay,\n  bool useOnCloseMarket,\n  bool useOnAssetsSentToEscrow,\n  bool useOnSetMaxTotalSupply,\n  bool useOnSetAnnualInterestAndReserveRatioBips\n) pure returns (HooksConfig hooks) {\n  assembly {\n    hooks := shl(96, hooksAddress)\n    hooks := or(hooks, shl(Bit_Enabled_Deposit, useOnDeposit))\n    hooks := or(hooks, shl(Bit_Enabled_QueueWithdrawal, useOnQueueWithdrawal))\n    hooks := or(hooks, shl(Bit_Enabled_ExecuteWithdrawal, useOnExecuteWithdrawal))\n    hooks := or(hooks, shl(Bit_Enabled_Transfer, useOnTransfer))\n    hooks := or(hooks, shl(Bit_Enabled_Borrow, useOnBorrow))\n    hooks := or(hooks, shl(Bit_Enabled_Repay, useOnRepay))\n    hooks := or(hooks, shl(Bit_Enabled_CloseMarket, useOnCloseMarket))\n    hooks := or(hooks, shl(Bit_Enabled_AssetsSentToEscrow, useOnAssetsSentToEscrow))\n    hooks := or(hooks, shl(Bit_Enabled_SetMaxTotalSupply, useOnSetMaxTotalSupply))\n    hooks := or(\n      hooks,\n      shl(\n        Bit_Enabled_SetAnnualInterestAndReserveRatioBips,\n        useOnSetAnnualInterestAndReserveRatioBips\n      )\n    )\n  }\n}\n\nlibrary LibHooksConfig {\n  function setHooksAddress(\n    HooksConfig hooks,\n    address _hooksAddress\n  ) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      // Shift twice to clear the address\n      updatedHooks := shr(96, shl(96, hooks))\n      // Set the new address\n      updatedHooks := or(updatedHooks, shl(96, _hooksAddress))\n    }\n  }\n\n  /**\n   * @dev Create a merged HooksConfig with the shared flags of `a` and `b`\n   *      and the address of `a`.\n   */\n  function mergeSharedFlags(\n    HooksConfig a,\n    HooksConfig b\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let addressA := shl(0x60, shr(0x60, a))\n      let flagsA := shl(0xa0, a)\n      let flagsB := shl(0xa0, b)\n      let mergedFlags := shr(0xa0, and(flagsA, flagsB))\n      merged := or(addressA, mergedFlags)\n    }\n  }\n\n  /**\n   * @dev Create a merged HooksConfig with the shared flags of `a` and `b`\n   *      and the address of `a`.\n   */\n  function mergeAllFlags(\n    HooksConfig a,\n    HooksConfig b\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let addressA := shl(0x60, shr(0x60, a))\n      let flagsA := shl(0xa0, a)\n      let flagsB := shl(0xa0, b)\n      let mergedFlags := shr(0xa0, or(flagsA, flagsB))\n      merged := or(addressA, mergedFlags)\n    }\n  }\n\n  function mergeFlags(\n    HooksConfig config,\n    HooksDeploymentConfig flags\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let _hooksAddress := shl(96, shr(96, config))\n      // Position flags at the end of the word\n      let configFlags := shr(0x50, config)\n      // Optional flags are already in the right position, required flags must be\n      // shifted to align with the other flags. The leading and trailing bits for all 3\n      // words will be masked out at the end\n      let _optionalFlags := flags\n      let _requiredFlags := shr(0x10, flags)\n      let mergedFlags := and(0xffff, or(and(configFlags, _optionalFlags), _requiredFlags))\n\n      merged := or(_hooksAddress, shl(0x50, mergedFlags))\n    }\n  }\n\n  function optionalFlags(HooksDeploymentConfig flags) internal pure returns (HooksConfig config) {\n    assembly {\n      config := shl(0x50, and(flags, 0xffff))\n    }\n  }\n\n  function requiredFlags(HooksDeploymentConfig flags) internal pure returns (HooksConfig config) {\n    assembly {\n      config := shl(0x40, and(flags, 0xffff0000))\n    }\n  }\n\n  // ========================================================================== //\n  //                              Parameter Readers                             //\n  // ========================================================================== //\n\n  function readFlag(HooksConfig hooks, uint256 bitsAfter) internal pure returns (bool flagged) {\n    assembly {\n      flagged := and(shr(bitsAfter, hooks), 1)\n    }\n  }\n\n  function setFlag(HooksConfig hooks, uint256 bitsAfter) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      updatedHooks := or(hooks, shl(bitsAfter, 1))\n    }\n  }\n\n  /// @dev Address of the hooks contract\n  function hooksAddress(HooksConfig hooks) internal pure returns (address _hooks) {\n    assembly {\n      _hooks := shr(96, hooks)\n    }\n  }\n\n  /// @dev Whether to call hook contract for deposit\n  function useOnDeposit(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Deposit);\n  }\n\n  /// @dev Whether to call hook contract for queueWithdrawal\n  function useOnQueueWithdrawal(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_QueueWithdrawal);\n  }\n\n  /// @dev Whether to call hook contract for executeWithdrawal\n  function useOnExecuteWithdrawal(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_ExecuteWithdrawal);\n  }\n\n  /// @dev Whether to call hook contract for transfer\n  function useOnTransfer(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Transfer);\n  }\n\n  /// @dev Whether to call hook contract for borrow\n  function useOnBorrow(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Borrow);\n  }\n\n  /// @dev Whether to call hook contract for repay\n  function useOnRepay(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Repay);\n  }\n\n  /// @dev Whether to call hook contract for closeMarket\n  function useOnCloseMarket(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_CloseMarket);\n  }\n\n  /// @dev Whether to call hook contract when account sanctioned\n  function useOnAssetsSentToEscrow(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_AssetsSentToEscrow);\n  }\n\n  /// @dev Whether to call hook contract for setMaxTotalSupply\n  function useOnSetMaxTotalSupply(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetMaxTotalSupply);\n  }\n\n  /// @dev Whether to call hook contract for setAnnualInterestAndReserveRatioBips\n  function useOnSetAnnualInterestAndReserveRatioBips(\n    HooksConfig hooks\n  ) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetAnnualInterestAndReserveRatioBips);\n  }\n\n  // ========================================================================== //\n  //                              Hook for deposit                              //\n  // ========================================================================== //\n\n  uint256 internal constant DepositCalldataSize = 0x24;\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant DepositHook_Base_Size = 0x0224;\n  uint256 internal constant DepositHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant DepositHook_State_Offset = 0x40;\n  uint256 internal constant DepositHook_ExtraData_Head_Offset = 0x1e0;\n  uint256 internal constant DepositHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant DepositHook_ExtraData_TailOffset = 0x0220;\n\n  function onDeposit(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onDepositSelector = uint32(IHooks.onDeposit.selector);\n    if (self.useOnDeposit()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), DepositCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onDeposit`\n        mstore(cdPointer, onDepositSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, DepositHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, DepositHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, DepositHook_ExtraData_Head_Offset),\n          DepositHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, DepositHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, DepositHook_ExtraData_TailOffset),\n          DepositCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(DepositHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                          Hook for queueWithdrawal                          //\n  // ========================================================================== //\n\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant QueueWithdrawalHook_Base_Size = 0x0224;\n  uint256 internal constant QueueWithdrawalHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant QueueWithdrawalHook_State_Offset = 0x40;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_Head_Offset = 0x1e0;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_TailOffset = 0x0220;\n\n  function onQueueWithdrawal(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onQueueWithdrawalSelector = uint32(IHooks.onQueueWithdrawal.selector);\n    if (self.useOnQueueWithdrawal()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onQueueWithdrawal`\n        mstore(cdPointer, onQueueWithdrawalSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, QueueWithdrawalHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, QueueWithdrawalHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, QueueWithdrawalHook_ExtraData_Head_Offset),\n          QueueWithdrawalHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, QueueWithdrawalHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, QueueWithdrawalHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(QueueWithdrawalHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                         Hook for executeWithdrawal                         //\n  // ========================================================================== //\n\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant ExecuteWithdrawalHook_Base_Size = 0x0224;\n  uint256 internal constant ExecuteWithdrawalHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant ExecuteWithdrawalHook_State_Offset = 0x40;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_Head_Offset = 0x1e0;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_TailOffset = 0x0220;\n\n  function onExecuteWithdrawal(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onExecuteWithdrawalSelector = uint32(IHooks.onExecuteWithdrawal.selector);\n    if (self.useOnExecuteWithdrawal()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onExecuteWithdrawal`\n        mstore(cdPointer, onExecuteWithdrawalSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, ExecuteWithdrawalHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, ExecuteWithdrawalHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, ExecuteWithdrawalHook_ExtraData_Head_Offset),\n          ExecuteWithdrawalHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, ExecuteWithdrawalHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, ExecuteWithdrawalHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(ExecuteWithdrawalHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                              Hook for transfer                             //\n  // ========================================================================== //\n\n  // Size of caller + from + to + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant TransferHook_Base_Size = 0x0264;\n  uint256 internal constant TransferHook_From_Offset = 0x20;\n  uint256 internal constant TransferHook_To_Offset = 0x40;\n  uint256 internal constant TransferHook_ScaledAmount_Offset = 0x60;\n  uint256 internal constant TransferHook_State_Offset = 0x80;\n  uint256 internal constant TransferHook_ExtraData_Head_Offset = 0x220;\n  uint256 internal constant TransferHook_ExtraData_Length_Offset = 0x0240;\n  uint256 internal constant TransferHook_ExtraData_TailOffset = 0x0260;\n\n  function onTransfer(\n    HooksConfig self,\n    address from,\n    address to,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onTransferSelector = uint32(IHooks.onTransfer.selector);\n    if (self.useOnTransfer()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onTransfer`\n        mstore(cdPointer, onTransferSelector)\n        // Write `caller` to hook calldata\n        mstore(headPointer, caller())\n        // Write `from` to hook calldata\n        mstore(add(headPointer, TransferHook_From_Offset), from)\n        // Write `to` to hook calldata\n        mstore(add(headPointer, TransferHook_To_Offset), to)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, TransferHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, TransferHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, TransferHook_ExtraData_Head_Offset),\n          TransferHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, TransferHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, TransferHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(TransferHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                               Hook for borrow                              //\n  // ========================================================================== //\n\n  uint256 internal constant BorrowCalldataSize = 0x24;\n  // Size of normalizedAmount + state + extraData.offset + extraData.length\n  uint256 internal constant BorrowHook_Base_Size = 0x0204;\n  uint256 internal constant BorrowHook_State_Offset = 0x20;\n  uint256 internal constant BorrowHook_ExtraData_Head_Offset = 0x01c0;\n  uint256 internal constant BorrowHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant BorrowHook_ExtraData_TailOffset = 0x0200;\n\n  function onBorrow(HooksConfig self, uint256 normalizedAmount, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onBorrowSelector = uint32(IHooks.onBorrow.selector);\n    if (self.useOnBorrow()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), BorrowCalldataSize)\n        let ptr := mload(0x40)\n        let headPointer := add(ptr, 0x20)\n\n        mstore(ptr, onBorrowSelector)\n        // Copy `normalizedAmount` to hook calldata\n        mstore(headPointer, normalizedAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, BorrowHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, BorrowHook_ExtraData_Head_Offset),\n          BorrowHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, BorrowHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, BorrowHook_ExtraData_TailOffset),\n          BorrowCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(RepayHook_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                               Hook for repay                               //\n  // ========================================================================== //\n\n  // Size of normalizedAmount + state + extraData.offset + extraData.length\n  uint256 internal constant RepayHook_Base_Size = 0x0204;\n  uint256 internal constant RepayHook_State_Offset = 0x20;\n  uint256 internal constant RepayHook_ExtraData_Head_Offset = 0x01c0;\n  uint256 internal constant RepayHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant RepayHook_ExtraData_TailOffset = 0x0200;\n\n  function onRepay(\n    HooksConfig self,\n    uint256 normalizedAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onRepaySelector = uint32(IHooks.onRepay.selector);\n    if (self.useOnRepay()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let ptr := mload(0x40)\n        let headPointer := add(ptr, 0x20)\n\n        mstore(ptr, onRepaySelector)\n        // Copy `normalizedAmount` to hook calldata\n        mstore(headPointer, normalizedAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, RepayHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(add(headPointer, RepayHook_ExtraData_Head_Offset), RepayHook_ExtraData_Length_Offset)\n        // Write length for `extraData`\n        mstore(add(headPointer, RepayHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, RepayHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(RepayHook_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                            Hook for closeMarket                            //\n  // ========================================================================== //\n\n  // Size of calldata to `market.closeMarket`\n  uint256 internal constant CloseMarketCalldataSize = 0x04;\n\n  // Base size of calldata for `hooks.onCloseMarket()`\n  uint256 internal constant CloseMarketHook_Base_Size = 0x01e4;\n  uint256 internal constant CloseMarketHook_ExtraData_Head_Offset = MarketStateSize;\n  uint256 internal constant CloseMarketHook_ExtraData_Length_Offset = 0x01c0;\n  uint256 internal constant CloseMarketHook_ExtraData_TailOffset = 0x01e0;\n\n  function onCloseMarket(HooksConfig self, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onCloseMarketSelector = uint32(IHooks.onCloseMarket.selector);\n    if (self.useOnCloseMarket()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), CloseMarketCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onCloseMarket`\n        mstore(cdPointer, onCloseMarketSelector)\n        // Copy market state to hook calldata\n        mcopy(headPointer, state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, CloseMarketHook_ExtraData_Head_Offset),\n          CloseMarketHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, CloseMarketHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, CloseMarketHook_ExtraData_TailOffset),\n          CloseMarketCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(CloseMarketHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                         Hook for setMaxTotalSupply                         //\n  // ========================================================================== //\n\n  uint256 internal constant SetMaxTotalSupplyCalldataSize = 0x24;\n  // Size of maxTotalSupply + state + extraData.offset + extraData.length\n  uint256 internal constant SetMaxTotalSupplyHook_Base_Size = 0x0204;\n  uint256 internal constant SetMaxTotalSupplyHook_State_Offset = 0x20;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_Head_Offset = 0x01c0;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_TailOffset = 0x0200;\n\n  function onSetMaxTotalSupply(\n    HooksConfig self,\n    uint256 maxTotalSupply,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onSetMaxTotalSupplySelector = uint32(IHooks.onSetMaxTotalSupply.selector);\n    if (self.useOnSetMaxTotalSupply()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), SetMaxTotalSupplyCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetMaxTotalSupply`\n        mstore(cdPointer, onSetMaxTotalSupplySelector)\n        // Write `maxTotalSupply` to hook calldata\n        mstore(headPointer, maxTotalSupply)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, SetMaxTotalSupplyHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetMaxTotalSupplyHook_ExtraData_Head_Offset),\n          SetMaxTotalSupplyHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, SetMaxTotalSupplyHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetMaxTotalSupplyHook_ExtraData_TailOffset),\n          SetMaxTotalSupplyCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetMaxTotalSupplyHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                       Hook for setAnnualInterestBips                       //\n  // ========================================================================== //\n\n  uint256 internal constant SetAnnualInterestBipsCalldataSize = 0x44;\n  // Size of annualInterestBips + state + extraData.offset + extraData.length\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_Base_Size = 0x0224;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ReserveRatioBits_Offset = 0x20;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_State_Offset = 0x40;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset =\n    0x0200;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_TailOffset = 0x0220;\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    HooksConfig self,\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState memory state\n  ) internal returns (uint16 newAnnualInterestBips, uint16 newReserveRatioBips) {\n    address target = self.hooksAddress();\n    uint32 onSetAnnualInterestBipsSelector = uint32(\n      IHooks.onSetAnnualInterestAndReserveRatioBips.selector\n    );\n    if (self.useOnSetAnnualInterestAndReserveRatioBips()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), SetAnnualInterestBipsCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetAnnualInterestBips`\n        mstore(cdPointer, onSetAnnualInterestBipsSelector)\n        // Write `annualInterestBips` to hook calldata\n        mstore(headPointer, annualInterestBips)\n        // Write `reserveRatioBips` to hook calldata\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ReserveRatioBits_Offset),\n          reserveRatioBips\n        )\n        // Copy market state to hook calldata\n        mcopy(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_State_Offset),\n          state,\n          MarketStateSize\n        )\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Head_Offset),\n          SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset),\n          extraCalldataBytes\n        )\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_TailOffset),\n          SetAnnualInterestBipsCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetAnnualInterestAndReserveRatioBipsHook_Base_Size, extraCalldataBytes)\n\n        // Returndata is expected to have the new values for `annualInterestBips` and `reserveRatioBips`\n        if or(\n          lt(returndatasize(), 0x40),\n          iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0x40))\n        ) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n\n        newAnnualInterestBips := and(mload(0), 0xffff)\n        newReserveRatioBips := and(mload(0x20), 0xffff)\n      }\n    } else {\n      (newAnnualInterestBips, newReserveRatioBips) = (annualInterestBips, reserveRatioBips);\n    }\n  }\n\n  // ========================================================================== //\n  //                       Hook for assets sent to escrow                       //\n  // ========================================================================== //\n\n  // Size of lender + asset + escrow + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant AssetsSentToEscrowHook_Base_Size = 0x0264;\n  uint256 internal constant AssetsSentToEscrowHook_Asset_Offset = 0x20;\n  uint256 internal constant AssetsSentToEscrowHook_Escrow_Offset = 0x40;\n  uint256 internal constant AssetsSentToEscrowHook_ScaledAmount_Offset = 0x60;\n  uint256 internal constant AssetsSentToEscrowHook_State_Offset = 0x80;\n  uint256 internal constant AssetsSentToEscrowHook_ExtraData_Head_Offset = 0x220;\n  uint256 internal constant AssetsSentToEscrowHook_ExtraData_Length_Offset = 0x0240;\n  uint256 internal constant AssetsSentToEscrowHook_ExtraData_TailOffset = 0x0260;\n\n  function onAssetsSentToEscrow(\n    HooksConfig self,\n    address lender,\n    address asset,\n    address escrow,\n    uint scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onAssetsSentToEscrowSelector = uint32(IHooks.onAssetsSentToEscrow.selector);\n    if (self.useOnAssetsSentToEscrow()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onAssetsSentToEscrow`\n        mstore(cdPointer, onAssetsSentToEscrowSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `asset` to hook calldata\n        mstore(add(headPointer, AssetsSentToEscrowHook_Asset_Offset), asset)\n        // Write `escrow` to hook calldata\n        mstore(add(headPointer, AssetsSentToEscrowHook_Escrow_Offset), escrow)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, AssetsSentToEscrowHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, AssetsSentToEscrowHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, AssetsSentToEscrowHook_ExtraData_Head_Offset),\n          AssetsSentToEscrowHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, AssetsSentToEscrowHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, AssetsSentToEscrowHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(AssetsSentToEscrowHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n}\n"
    },
    "src/spherex/ISphereXEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\npragma solidity ^0.8.20;\n\n/// @dev this struct is used to reduce the stack usage of the modifiers.\nstruct ModifierLocals {\n  bytes32[] storageSlots;\n  bytes32[] valuesBefore;\n  uint256 gas;\n  address engine;\n}\n\n/// @title Interface for SphereXEngine - definitions of core functionality\n/// @author SphereX Technologies ltd\n/// @notice This interface is imported by SphereXProtected, so that SphereXProtected can call functions from SphereXEngine\n/// @dev Full docs of these functions can be found in SphereXEngine\ninterface ISphereXEngine {\n  function sphereXValidatePre(\n    int256 num,\n    address sender,\n    bytes calldata data\n  ) external returns (bytes32[] memory);\n\n  function sphereXValidatePost(\n    int256 num,\n    uint256 gas,\n    bytes32[] calldata valuesBefore,\n    bytes32[] calldata valuesAfter\n  ) external;\n\n  function sphereXValidateInternalPre(int256 num) external returns (bytes32[] memory);\n\n  function sphereXValidateInternalPost(\n    int256 num,\n    uint256 gas,\n    bytes32[] calldata valuesBefore,\n    bytes32[] calldata valuesAfter\n  ) external;\n\n  function addAllowedSenderOnChain(address sender) external;\n\n  /// This function is taken as is from OZ IERC165, we don't inherit from OZ\n  /// to avoid collisions with the customer OZ version.\n  /// @dev Returns true if this contract implements the interface defined by\n  /// `interfaceId`. See the corresponding\n  /// https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n  /// to learn more about how these ids are created.\n  /// This function call must use less than 30 000 gas.\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/spherex/SphereXProtectedEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nfunction emit_ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin) {\n  assembly {\n    mstore(0, oldSphereXAdmin)\n    mstore(0x20, newSphereXAdmin)\n    log1(0, 0x40, 0x2ac55ae7ba47db34b5334622acafeb34a65daf143b47019273185d64c73a35a5)\n  }\n}\n\nfunction emit_ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress) {\n  assembly {\n    mstore(0, oldEngineAddress)\n    mstore(0x20, newEngineAddress)\n    log1(0, 0x40, 0xf33499cccaa0611882086224cc48cd82ef54b66a4d2edf4ed67108dd516896d5)\n  }\n}\n\nfunction emit_SpherexAdminTransferStarted(address currentAdmin, address pendingAdmin) {\n  assembly {\n    mstore(0, currentAdmin)\n    mstore(0x20, pendingAdmin)\n    log1(0, 0x40, 0x5778f1547abbbb86090a43c32aec38334b31df4beeb6f8f3fa063f593b53a526)\n  }\n}\n\nfunction emit_SpherexAdminTransferCompleted(address oldAdmin, address newAdmin) {\n  assembly {\n    mstore(0, oldAdmin)\n    mstore(0x20, newAdmin)\n    log1(0, 0x40, 0x67ebaebcd2ca5a91a404e898110f221747e8d15567f2388a34794aab151cf3e6)\n  }\n}\n\nfunction emit_NewAllowedSenderOnchain(address sender) {\n  assembly {\n    mstore(0, sender)\n    log1(0, 0x20, 0x6de0a1fd3a59e5479e6480ba65ef28d4f3ab8143c2c631bbfd9969ab39074797)\n  }\n}\n"
    },
    "src/spherex/SphereXProtectedErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nfunction revert_SphereXOperatorRequired() pure {\n  assembly {\n    mstore(0, 0x4ee0b8f8)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXAdminRequired() pure {\n  assembly {\n    mstore(0, 0x6222a550)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXOperatorOrAdminRequired() pure {\n  assembly {\n    mstore(0, 0xb2dbeb59)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXNotPendingAdmin() pure {\n  assembly {\n    mstore(0, 0x4d28a58e)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXNotEngine() pure {\n  assembly {\n    mstore(0, 0x7dcb7ada)\n    revert(0x1c, 0x04)\n  }\n}\n"
    },
    "lib/solady/src/utils/LibBit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, byte(shr(r, x), hex\"00000101020202020303030303030303\"))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(iszero(x), xor(255,\n                or(r, byte(shr(r, x), hex\"00000101020202020303030303030303\"))))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            let b := and(x, add(not(x), 1))\n\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\n            let m := not(0)\n            r := x\n            for { let s := 128 } 1 {} {\n                m := xor(m, shl(s, m))\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\n                s := shr(1, s)\n                if iszero(s) { break }\n            }\n        }\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            let m := not(0)\n            r := x\n            for { let s := 128 } 1 {} {\n                m := xor(m, shl(s, m))\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\n                s := shr(1, s)\n                if eq(s, 4) { break }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\n    // Non-zero values are true, zero is false.\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\n    // Usually, if not always, the bool result of a regular Solidity expression,\n    // or the argument of a public/external function will be a clean bool.\n    // You can usually use the raw variants for more performance.\n    // If uncertain, test (best with exact compiler settings).\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\n\n    /// @dev Returns `x & y`. Inputs must be clean.\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns `x | y`. Inputs must be clean.\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\n    function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './Errors.sol';\n\nlibrary SafeCastLib {\n  function _assertNonOverflow(bool didNotOverflow) private pure {\n    assembly {\n      if iszero(didNotOverflow) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n    }\n  }\n\n  function toUint8(uint256 x) internal pure returns (uint8 y) {\n    _assertNonOverflow(x == (y = uint8(x)));\n  }\n\n  function toUint16(uint256 x) internal pure returns (uint16 y) {\n    _assertNonOverflow(x == (y = uint16(x)));\n  }\n\n  function toUint24(uint256 x) internal pure returns (uint24 y) {\n    _assertNonOverflow(x == (y = uint24(x)));\n  }\n\n  function toUint32(uint256 x) internal pure returns (uint32 y) {\n    _assertNonOverflow(x == (y = uint32(x)));\n  }\n\n  function toUint40(uint256 x) internal pure returns (uint40 y) {\n    _assertNonOverflow(x == (y = uint40(x)));\n  }\n\n  function toUint48(uint256 x) internal pure returns (uint48 y) {\n    _assertNonOverflow(x == (y = uint48(x)));\n  }\n\n  function toUint56(uint256 x) internal pure returns (uint56 y) {\n    _assertNonOverflow(x == (y = uint56(x)));\n  }\n\n  function toUint64(uint256 x) internal pure returns (uint64 y) {\n    _assertNonOverflow(x == (y = uint64(x)));\n  }\n\n  function toUint72(uint256 x) internal pure returns (uint72 y) {\n    _assertNonOverflow(x == (y = uint72(x)));\n  }\n\n  function toUint80(uint256 x) internal pure returns (uint80 y) {\n    _assertNonOverflow(x == (y = uint80(x)));\n  }\n\n  function toUint88(uint256 x) internal pure returns (uint88 y) {\n    _assertNonOverflow(x == (y = uint88(x)));\n  }\n\n  function toUint96(uint256 x) internal pure returns (uint96 y) {\n    _assertNonOverflow(x == (y = uint96(x)));\n  }\n\n  function toUint104(uint256 x) internal pure returns (uint104 y) {\n    _assertNonOverflow(x == (y = uint104(x)));\n  }\n\n  function toUint112(uint256 x) internal pure returns (uint112 y) {\n    _assertNonOverflow(x == (y = uint112(x)));\n  }\n\n  function toUint120(uint256 x) internal pure returns (uint120 y) {\n    _assertNonOverflow(x == (y = uint120(x)));\n  }\n\n  function toUint128(uint256 x) internal pure returns (uint128 y) {\n    _assertNonOverflow(x == (y = uint128(x)));\n  }\n\n  function toUint136(uint256 x) internal pure returns (uint136 y) {\n    _assertNonOverflow(x == (y = uint136(x)));\n  }\n\n  function toUint144(uint256 x) internal pure returns (uint144 y) {\n    _assertNonOverflow(x == (y = uint144(x)));\n  }\n\n  function toUint152(uint256 x) internal pure returns (uint152 y) {\n    _assertNonOverflow(x == (y = uint152(x)));\n  }\n\n  function toUint160(uint256 x) internal pure returns (uint160 y) {\n    _assertNonOverflow(x == (y = uint160(x)));\n  }\n\n  function toUint168(uint256 x) internal pure returns (uint168 y) {\n    _assertNonOverflow(x == (y = uint168(x)));\n  }\n\n  function toUint176(uint256 x) internal pure returns (uint176 y) {\n    _assertNonOverflow(x == (y = uint176(x)));\n  }\n\n  function toUint184(uint256 x) internal pure returns (uint184 y) {\n    _assertNonOverflow(x == (y = uint184(x)));\n  }\n\n  function toUint192(uint256 x) internal pure returns (uint192 y) {\n    _assertNonOverflow(x == (y = uint192(x)));\n  }\n\n  function toUint200(uint256 x) internal pure returns (uint200 y) {\n    _assertNonOverflow(x == (y = uint200(x)));\n  }\n\n  function toUint208(uint256 x) internal pure returns (uint208 y) {\n    _assertNonOverflow(x == (y = uint208(x)));\n  }\n\n  function toUint216(uint256 x) internal pure returns (uint216 y) {\n    _assertNonOverflow(x == (y = uint216(x)));\n  }\n\n  function toUint224(uint256 x) internal pure returns (uint224 y) {\n    _assertNonOverflow(x == (y = uint224(x)));\n  }\n\n  function toUint232(uint256 x) internal pure returns (uint232 y) {\n    _assertNonOverflow(x == (y = uint232(x)));\n  }\n\n  function toUint240(uint256 x) internal pure returns (uint240 y) {\n    _assertNonOverflow(x == (y = uint240(x)));\n  }\n\n  function toUint248(uint256 x) internal pure returns (uint248 y) {\n    _assertNonOverflow(x == (y = uint248(x)));\n  }\n}\n"
    },
    "src/libraries/FeeMath.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './MathUtils.sol';\nimport './SafeCastLib.sol';\nimport './MarketState.sol';\n\nusing SafeCastLib for uint256;\nusing MathUtils for uint256;\n\nlibrary FeeMath {\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   *\n   * @param rateBip The interest rate, in bips\n   * @param timeDelta The time elapsed since the last interest accrual\n   * @return result The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterestFromBips(\n    uint256 rateBip,\n    uint256 timeDelta\n  ) internal pure returns (uint256 result) {\n    uint256 rate = rateBip.bipToRay();\n    uint256 accumulatedInterestRay = rate * timeDelta;\n    unchecked {\n      return accumulatedInterestRay / SECONDS_IN_365_DAYS;\n    }\n  }\n\n  function calculateBaseInterest(\n    MarketState memory state,\n    uint256 timestamp\n  ) internal pure returns (uint256 baseInterestRay) {\n    baseInterestRay = MathUtils.calculateLinearInterestFromBips(\n      state.annualInterestBips,\n      timestamp - state.lastInterestAccruedTimestamp\n    );\n  }\n\n  function applyProtocolFee(\n    MarketState memory state,\n    uint256 baseInterestRay,\n    uint256 protocolFeeBips\n  ) internal pure returns (uint256 protocolFee) {\n    // Protocol fee is charged in addition to the interest paid to lenders.\n    uint256 protocolFeeRay = protocolFeeBips.bipMul(baseInterestRay);\n    protocolFee = uint256(state.scaledTotalSupply).rayMul(\n      uint256(state.scaleFactor).rayMul(protocolFeeRay)\n    );\n    state.accruedProtocolFees = (state.accruedProtocolFees + protocolFee).toUint128();\n  }\n\n  function updateDelinquency(\n    MarketState memory state,\n    uint256 timestamp,\n    uint256 delinquencyFeeBips,\n    uint256 delinquencyGracePeriod\n  ) internal pure returns (uint256 delinquencyFeeRay) {\n    // Calculate the number of seconds the borrower spent in penalized\n    // delinquency since the last update.\n    uint256 timeWithPenalty = updateTimeDelinquentAndGetPenaltyTime(\n      state,\n      delinquencyGracePeriod,\n      timestamp - state.lastInterestAccruedTimestamp\n    );\n\n    if (timeWithPenalty > 0) {\n      // Calculate penalty fees on the interest accrued.\n      delinquencyFeeRay = calculateLinearInterestFromBips(delinquencyFeeBips, timeWithPenalty);\n    }\n  }\n\n  /**\n   * @notice  Calculate the number of seconds that the market has been in\n   *          penalized delinquency since the last update, and update\n   *          `timeDelinquent` in state.\n   *\n   * @dev When `isDelinquent`, equivalent to:\n   *        max(0, timeDelta - max(0, delinquencyGracePeriod - previousTimeDelinquent))\n   *      When `!isDelinquent`, equivalent to:\n   *        min(timeDelta, max(0, previousTimeDelinquent - delinquencyGracePeriod))\n   *\n   * @param state Encoded state parameters\n   * @param delinquencyGracePeriod Seconds in delinquency before penalties apply\n   * @param timeDelta Seconds since the last update\n   * @param `timeWithPenalty` Number of seconds since the last update where\n   *        the market was in delinquency outside of the grace period.\n   */\n  function updateTimeDelinquentAndGetPenaltyTime(\n    MarketState memory state,\n    uint256 delinquencyGracePeriod,\n    uint256 timeDelta\n  ) internal pure returns (uint256 /* timeWithPenalty */) {\n    // Seconds in delinquency at last update\n    uint256 previousTimeDelinquent = state.timeDelinquent;\n\n    if (state.isDelinquent) {\n      // Since the borrower is still delinquent, increase the total\n      // time in delinquency by the time elapsed.\n      state.timeDelinquent = (previousTimeDelinquent + timeDelta).toUint32();\n\n      // Calculate the number of seconds the borrower had remaining\n      // in the grace period.\n      uint256 secondsRemainingWithoutPenalty = delinquencyGracePeriod.satSub(\n        previousTimeDelinquent\n      );\n\n      // Penalties apply for the number of seconds the market spent in\n      // delinquency outside of the grace period since the last update.\n      return timeDelta.satSub(secondsRemainingWithoutPenalty);\n    }\n\n    // Reduce the total time in delinquency by the time elapsed, stopping\n    // when it reaches zero.\n    state.timeDelinquent = previousTimeDelinquent.satSub(timeDelta).toUint32();\n\n    // Calculate the number of seconds the old timeDelinquent had remaining\n    // outside the grace period, or zero if it was already in the grace period.\n    uint256 secondsRemainingWithPenalty = previousTimeDelinquent.satSub(delinquencyGracePeriod);\n\n    // Only apply penalties for the remaining time outside of the grace period.\n    return MathUtils.min(secondsRemainingWithPenalty, timeDelta);\n  }\n\n  /**\n   * @dev Calculates interest and delinquency/protocol fees accrued since last state update\n   *      and applies it to cached state, returning the rates for base interest and delinquency\n   *      fees and the normalized amount of protocol fees accrued.\n   *\n   *      Takes `timestamp` as input to allow separate calculation of interest\n   *      before and after withdrawal batch expiry.\n   *\n   * @param state Market scale parameters\n   * @param protocolFeeBips Protocol fee rate (in bips)\n   * @param delinquencyFeeBips Delinquency fee rate (in bips)\n   * @param delinquencyGracePeriod Grace period (in seconds) before delinquency fees apply\n   * @param timestamp Time to calculate interest and fees accrued until\n   * @return baseInterestRay Interest accrued to lenders (ray)\n   * @return delinquencyFeeRay Penalty fee incurred by borrower for delinquency (ray).\n   * @return protocolFee Protocol fee charged on interest (normalized token amount).\n   */\n  function updateScaleFactorAndFees(\n    MarketState memory state,\n    uint256 protocolFeeBips,\n    uint256 delinquencyFeeBips,\n    uint256 delinquencyGracePeriod,\n    uint256 timestamp\n  )\n    internal\n    pure\n    returns (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee)\n  {\n    baseInterestRay = state.calculateBaseInterest(timestamp);\n\n    if (protocolFeeBips > 0) {\n      protocolFee = state.applyProtocolFee(baseInterestRay, protocolFeeBips);\n    }\n\n    if (delinquencyFeeBips > 0) {\n      delinquencyFeeRay = state.updateDelinquency(\n        timestamp,\n        delinquencyFeeBips,\n        delinquencyGracePeriod\n      );\n    }\n\n    // Calculate new scaleFactor\n    uint256 prevScaleFactor = state.scaleFactor;\n    uint256 scaleFactorDelta = prevScaleFactor.rayMul(baseInterestRay + delinquencyFeeRay);\n\n    state.scaleFactor = (prevScaleFactor + scaleFactorDelta).toUint112();\n    state.lastInterestAccruedTimestamp = uint32(timestamp);\n  }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "src/=src/",
      "forge-std/=lib/forge-std/src/",
      "ds-test/=lib/ds-test/src/",
      "solmate/=lib/solmate/src/",
      "solady/=lib/solady/src/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "sol-utils/=lib/sol-utils/src/",
      "ethereum-access-token/=lib/ethereum-access-token/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "vulcan/=lib/vulcan/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 4294967295
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "ir",
          "irOptimized",
          "metadata"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "libraries": {}
  }
}