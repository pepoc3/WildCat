{"language":"Solidity","sources":{"src/access/AccessControlHooks.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport '../libraries/BoolUtils.sol';\nimport '../libraries/MathUtils.sol';\nimport '../types/RoleProvider.sol';\nimport '../types/LenderStatus.sol';\nimport './IRoleProvider.sol';\nimport './MarketConstraintHooks.sol';\n\nusing BoolUtils for bool;\nusing MathUtils for uint256;\n\n/**\n * @title AccessControlHooks\n * @dev Hooks contract for wildcat markets. Restricts access to deposits\n *      to accounts that have credentials from approved role providers, or\n *      which are manually approved by the borrower.\n *\n *      Withdrawals are restricted in the same way for users that have not\n *      made a deposit, while users who have made a deposit at any point\n *      remain approved even if they are later removed.\n *\n *      Deposit access may be canceled by the borrower.\n */\ncontract AccessControlHooks is MarketConstraintHooks {\n  // ========================================================================== //\n  //                                   Events                                   //\n  // ========================================================================== //\n\n  event RoleProviderUpdated(\n    address indexed providerAddress,\n    uint32 timeToLive,\n    uint24 pullProviderIndex\n  );\n  event RoleProviderAdded(\n    address indexed providerAddress,\n    uint32 timeToLive,\n    uint24 pullProviderIndex\n  );\n  event RoleProviderRemoved(address indexed providerAddress, uint24 pullProviderIndex);\n  event AccountBlockedFromDeposits(address indexed accountAddress);\n  event AccountUnblockedFromDeposits(address indexed accountAddress);\n  event AccountAccessGranted(\n    address indexed providerAddress,\n    address indexed accountAddress,\n    uint32 credentialTimestamp\n  );\n  event AccountAccessRevoked(address indexed accountAddress);\n  event AccountMadeFirstDeposit(address indexed accountAddress);\n\n  // ========================================================================== //\n  //                                   Errors                                   //\n  // ========================================================================== //\n\n  error CallerNotBorrower();\n  error ProviderNotFound();\n  error ProviderCanNotReplaceCredential();\n  error ProviderCanNotRevokeCredential();\n  /// @dev Error thrown when a provider grants a credential that is already expired.\n  error GrantedCredentialExpired();\n  /// @dev Error thrown when a provider is called to validate a credential and the\n  ///      returndata can not be decoded as a uint.\n  error InvalidCredentialReturned();\n  /// @dev Error thrown when a user does not have a valid credential\n  error NotApprovedLender();\n  error InvalidArrayLength();\n  error NotHookedMarket();\n\n  // ========================================================================== //\n  //                                    State                                   //\n  // ========================================================================== //\n\n  address public immutable borrower;\n\n  mapping(address => LenderStatus) internal _lenderStatus;\n  // Provider data is duplicated in the array and mapping to allow\n  // push providers to update in a single step and pull providers to\n  // be looped over without having to access the mapping.\n  RoleProvider[] internal _pullProviders;\n  mapping(address => RoleProvider) internal _roleProviders;\n\n  HooksDeploymentConfig public immutable override config;\n\n  mapping(address => bool) public hookedMarkets;\n\n  // ========================================================================== //\n  //                                  Modifiers                                 //\n  // ========================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert CallerNotBorrower();\n    _;\n  }\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  /**\n   * @param _deployer Address of the account that called the factory.\n   * @param {} unused extra bytes to match the constructor signature\n   *  restrictedFunctions Configuration specifying which functions to apply\n   *                            access controls to.\n   */\n  constructor(address _deployer, bytes memory /* args */) IHooks() {\n    borrower = _deployer;\n    // Allow deployer to grant roles with no expiry\n    _roleProviders[_deployer] = encodeRoleProvider(\n      type(uint32).max,\n      _deployer,\n      NotPullProviderIndex\n    );\n    HooksConfig optionalFlags = encodeHooksConfig({\n      hooksAddress: address(0),\n      useOnDeposit: true,\n      useOnQueueWithdrawal: true,\n      useOnExecuteWithdrawal: true,\n      useOnTransfer: true,\n      useOnBorrow: false,\n      useOnRepay: false,\n      useOnCloseMarket: false,\n      useOnAssetsSentToEscrow: false,\n      useOnSetMaxTotalSupply: false,\n      useOnSetAnnualInterestAndReserveRatioBips: false\n    });\n    HooksConfig requiredFlags = EmptyHooksConfig.setFlag(\n      Bit_Enabled_SetAnnualInterestAndReserveRatioBips\n    );\n    config = encodeHooksDeploymentConfig(optionalFlags, requiredFlags);\n  }\n\n  function version() external pure override returns (string memory) {\n    return 'SingleBorrowerAccessControlHooks';\n  }\n\n  /**\n   * @dev Called when market is deployed using this contract as its `hooks`.\n   *\n   *      Note: Called inside the root `onCreateMarket` in the base contract,\n   *      so no need to verify the caller is the factory.\n   */\n  function _onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData\n  ) internal override {\n    if (deployer != borrower) revert CallerNotBorrower();\n    // Validate the deploy parameters\n    super._onCreateMarket(deployer, marketAddress, parameters, hooksData);\n    hookedMarkets[address(marketAddress)] = true;\n  }\n\n  // ========================================================================== //\n  //                             Provider management                            //\n  // ========================================================================== //\n\n  /**\n   * @dev Adds or updates a role provider that is able to grant user access.\n   *      If it is not already approved, it is added to `_roleProviders` and,\n   *      if the provider can refresh credentials, added to `pullProviders`.\n   *      If the provider is already approved, only updates `timeToLive`.\n   */\n  function addRoleProvider(address providerAddress, uint32 timeToLive) external onlyBorrower {\n    RoleProvider provider = _roleProviders[providerAddress];\n    if (provider.isNull()) {\n      bool isPullProvider = IRoleProvider(providerAddress).isPullProvider();\n      // Role providers that are not pull providers have `pullProviderIndex` set to\n      // `NotPullProviderIndex` (max uint24) to indicate they do not refresh credentials.\n      provider = encodeRoleProvider(\n        timeToLive,\n        providerAddress,\n        isPullProvider ? uint24(_pullProviders.length) : NotPullProviderIndex\n      );\n      if (isPullProvider) {\n        _pullProviders.push(provider);\n      }\n      emit RoleProviderAdded(providerAddress, timeToLive, provider.pullProviderIndex());\n    } else {\n      // If provider already exists, the only value that can be updated is the TTL\n      provider = provider.setTimeToLive(timeToLive);\n      uint24 pullProviderIndex = provider.pullProviderIndex();\n      if (pullProviderIndex != NotPullProviderIndex) {\n        _pullProviders[pullProviderIndex] = provider;\n      } else {}\n      emit RoleProviderUpdated(providerAddress, timeToLive, pullProviderIndex);\n    }\n    // Update the provider in storage\n    _roleProviders[providerAddress] = provider;\n  }\n\n  /**\n   * @dev Removes a role provider from the `_roleProviders` mapping and, if it is a\n   *      pull provider, from the `_pullProviders` array.\n   */\n  function removeRoleProvider(address providerAddress) external onlyBorrower {\n    RoleProvider provider = _roleProviders[providerAddress];\n    if (provider.isNull()) revert ProviderNotFound();\n    // Remove the provider from `_roleProviders`\n    _roleProviders[providerAddress] = EmptyRoleProvider;\n    emit RoleProviderRemoved(providerAddress, provider.pullProviderIndex());\n    // If the provider is a pull provider, remove it from `_pullProviders`\n    if (provider.isPullProvider()) {\n      _removePullProvider(provider.pullProviderIndex());\n    }\n  }\n\n  /**\n   * @dev Remove a pull provider from the `_pullProviders` array.\n   *      If the provider is not the last in the array, the last provider\n   *      is moved to the index of the provider being removed, so its index\n   *      must also be updated in the `_roleProviders` mapping.\n   */\n  function _removePullProvider(uint24 indexToRemove) internal {\n    // Get the last index in the array\n    uint256 lastIndex = _pullProviders.length - 1;\n    // If the index to remove is the last index, just pop the last element\n    if (indexToRemove == lastIndex) {\n      _pullProviders.pop();\n      return;\n    }\n    // If the index to remove is not the last index, move the last element\n    // to the index of the element being removed\n    RoleProvider lastProvider = _pullProviders[lastIndex].setPullProviderIndex(indexToRemove);\n    _pullProviders[indexToRemove] = lastProvider;\n    _pullProviders.pop();\n    address lastProviderAddress = lastProvider.providerAddress();\n    _roleProviders[lastProviderAddress] = lastProvider;\n    // Emit an event to notify that the provider's index has been updated\n    emit RoleProviderUpdated(lastProviderAddress, lastProvider.timeToLive(), indexToRemove);\n  }\n\n  // ========================================================================== //\n  //                              Provider queries                              //\n  // ========================================================================== //\n\n  function getRoleProvider(address providerAddress) external view returns (RoleProvider) {\n    return _roleProviders[providerAddress];\n  }\n\n  function getPullProviders() external view returns (RoleProvider[] memory) {\n    return _pullProviders;\n  }\n\n  // ========================================================================== //\n  //                                Role queries                                //\n  // ========================================================================== //\n\n  function getPreviousLenderStatus(\n    address accountAddress\n  ) external view returns (LenderStatus memory status) {\n    status = _lenderStatus[accountAddress];\n  }\n\n  /**\n   * @dev Retrieves the current status of a lender, attempting to find a valid\n   *      credential if their current one is invalid or non-existent.\n   *\n   *      If the lender has an expired credential, will attempt to refresh it\n   *      with the previous provider if it is still supported.\n   *\n   *      If the lender has no credential, or one from a provider that is no longer\n   *      supported or will not refresh it, will loop over all providers to find\n   *      a valid credential.\n   */\n  function getLenderStatus(\n    address accountAddress\n  ) external view returns (LenderStatus memory status) {\n    status = _lenderStatus[accountAddress];\n\n    uint256 pullProviderIndexToSkip = type(uint256).max;\n\n    // Check if user has an existing credential\n    if (status.lastApprovalTimestamp > 0) {\n      RoleProvider provider = _roleProviders[status.lastProvider];\n      if (!provider.isNull()) {\n        // If credential is not expired and the provider is still\n        // supported, the lender has a valid credential.\n        if (status.credentialNotExpired(provider)) return status;\n\n        // If credential is expired but the provider is still supported and\n        // allows refreshing (i.e. it's a pull provider), try to refresh.\n        if (status.canRefresh) {\n          if (_tryGetCredential(status, provider, accountAddress)) {\n            return status;\n          }\n          // If refresh fails, provider should be skipped in the query loop\n          pullProviderIndexToSkip = provider.pullProviderIndex();\n        }\n      }\n      // If credential could not be refreshed or the provider is no longer\n      // supported, remove it\n      status.unsetCredential();\n    }\n\n    // Loop over all pull providers to find a valid role for the lender\n    if (_loopTryGetCredential(status, accountAddress, pullProviderIndexToSkip)) {\n      return status;\n    }\n  }\n\n  // ========================================================================== //\n  //                                Role actions                                //\n  // ========================================================================== //\n\n  /**\n   * @dev Grants a role to an account by updating the account's status.\n   *      Can only be called by an approved role provider.\n   *\n   *      If the account has an existing credential, it can only be updated if:\n   *      - the previous credential's provider is no longer supported, OR\n   *      - the caller is the previous role provider, OR\n   *      - the new expiry is later than the current expiry\n   */\n  function grantRole(address account, uint32 roleGrantedTimestamp) external {\n    RoleProvider callingProvider = _roleProviders[msg.sender];\n\n    if (callingProvider.isNull()) revert ProviderNotFound();\n\n    _grantRole(callingProvider, account, roleGrantedTimestamp);\n  }\n\n  /**\n   * @dev Grants roles to multiple accounts by updating their statuses.\n   *      Can only be called by an approved role provider.\n   *\n   *      If any account has an existing credential, it can only be updated if:\n   *      - the previous credential's provider is no longer supported, OR\n   *      - the caller is the previous role provider, OR\n   *      - the new expiry is later than the current expiry\n   */\n  function grantRoles(address[] memory accounts, uint32[] memory roleGrantedTimestamps) external {\n    RoleProvider callingProvider = _roleProviders[msg.sender];\n\n    if (callingProvider.isNull()) revert ProviderNotFound();\n\n    if (accounts.length != roleGrantedTimestamps.length) revert InvalidArrayLength();\n    for (uint256 i = 0; i < accounts.length; i++) {\n      _grantRole(callingProvider, accounts[i], roleGrantedTimestamps[i]);\n    }\n  }\n\n  function _grantRole(\n    RoleProvider callingProvider,\n    address account,\n    uint32 roleGrantedTimestamp\n  ) internal {\n    LenderStatus memory status = _lenderStatus[account];\n\n    uint256 newExpiry = callingProvider.calculateExpiry(roleGrantedTimestamp);\n\n    // Check if the new credential is still valid\n    if (newExpiry < block.timestamp) revert GrantedCredentialExpired();\n\n    // Check if the account has ever had a credential\n    if (status.hasCredential()) {\n      RoleProvider lastProvider = _roleProviders[status.lastProvider];\n\n      // Check if the provider that last granted access is still supported\n      if (!lastProvider.isNull()) {\n        uint256 oldExpiry = lastProvider.calculateExpiry(status.lastApprovalTimestamp);\n\n        // Can only update role if the caller is the previous role provider or the new\n        // expiry is greater than the previous expiry.\n        if (!((status.lastProvider == msg.sender).or(newExpiry > oldExpiry))) {\n          revert ProviderCanNotReplaceCredential();\n        }\n      }\n    }\n\n    _setCredentialAndEmitAccessGranted(status, callingProvider, account, roleGrantedTimestamp);\n  }\n\n  function revokeRole(address account) external {\n    LenderStatus memory status = _lenderStatus[account];\n    if (status.lastProvider != msg.sender) {\n      revert ProviderCanNotRevokeCredential();\n    }\n    status.unsetCredential();\n    _lenderStatus[account] = status;\n    emit AccountAccessRevoked(account);\n  }\n\n  function blockFromDeposits(address account) external onlyBorrower {\n    LenderStatus memory status = _lenderStatus[account];\n    if (status.hasCredential()) {\n      status.unsetCredential();\n      emit AccountAccessRevoked(account);\n    }\n    status.isBlockedFromDeposits = true;\n    _lenderStatus[account] = status;\n    emit AccountBlockedFromDeposits(account);\n  }\n\n  function unblockFromDeposits(address account) external onlyBorrower {\n    LenderStatus memory status = _lenderStatus[account];\n    status.isBlockedFromDeposits = false;\n    _lenderStatus[account] = status;\n    emit AccountUnblockedFromDeposits(account);\n  }\n\n  /**\n   * @dev Tries to pull an active credential for an account from a pull provider.\n   *      If one exists, updates the account in memory and returns true.\n   *\n   *      Note: Does not check that provider is a pull provider - should\n   *      only be called if that has already been checked.\n   */\n  function _tryGetCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    address accountAddress\n  ) internal view returns (bool isApproved) {\n    // Query provider for user approval\n    address providerAddress = provider.providerAddress();\n\n    uint32 credentialTimestamp;\n    uint getCredentialSelector = uint32(IRoleProvider.getCredential.selector);\n    assembly {\n      mstore(0x00, getCredentialSelector)\n      mstore(0x20, accountAddress)\n      // Call the provider and check if the return data is valid\n      if and(gt(returndatasize(), 0x1f), staticcall(gas(), providerAddress, 0x1c, 0x24, 0, 0x20)) {\n        // If the return data is valid, set `credentialTimestamp` to the returned word\n        // with a uint32 mask applied\n        credentialTimestamp := and(mload(0), 0xffffffff)\n      }\n    }\n\n    // If the returned timestamp is null or greater than the current time, return false.\n    if (credentialTimestamp == 0 || credentialTimestamp > block.timestamp) {\n      return false;\n    }\n\n    // If credential is still valid, update credential\n    if (provider.calculateExpiry(credentialTimestamp) >= block.timestamp) {\n      // User is approved, update status with new expiry and last provider\n      status.setCredential(provider, credentialTimestamp);\n      return true;\n    }\n  }\n\n  function _readAddress(bytes calldata hooksData) internal pure returns (address providerAddress) {\n    assembly {\n      providerAddress := shr(96, calldataload(hooksData.offset))\n    }\n  }\n\n  /**\n   * @dev Uses the data added to the end of the base call to the market function to call\n   *      `validateCredential` on the selected provider. Returns false if the provider does not\n   *      exist, the call fails, or the credential is invalid. Only reverts if the call succeeds but\n   *      does not return the correct amount of data.\n   *\n   *      The calldata to the market function must have a suffix encoded as (address, bytes), where\n   *      the address is packed and the bytes do not contain an offset or length. For example, if\n   *      the market function were `fn(uint256 arg0)` and the user provided a 32 byte `accessToken`\n   *      for provider `provider0`, the calldata to the market would be:\n   *      [0:4] selector\n   *      [4:36] arg0\n   *      [36:58] provider0\n   *      [58:90] `accessToken`\n   */\n  function _tryValidateCredential(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool) {\n    uint validateSelector = uint32(IRoleProvider.validateCredential.selector);\n    address providerAddress = _readAddress(hooksData);\n    RoleProvider provider = _roleProviders[providerAddress];\n    if (provider.isNull()) return false;\n    uint credentialTimestamp;\n    uint invalidCredentialReturnedSelector = uint32(InvalidCredentialReturned.selector);\n    assembly {\n      // Get the offset to the extra data provided in the hooks call, after the provider.\n      let validateDataCalldataPointer := add(hooksData.offset, 0x14)\n      // Encode the call to `validateCredential(address account, bytes calldata data)`\n      let calldataPointer := mload(0x40)\n      // The selector is right aligned, so the real calldata buffer begins at calldataPointer + 28\n      mstore(calldataPointer, validateSelector)\n      mstore(add(calldataPointer, 0x20), accountAddress)\n      // Write the calldata offset to `data`\n      mstore(add(calldataPointer, 0x40), 0x40)\n      // Get length of the data segment in the hooks data\n      let dataLength := sub(hooksData.length, 0x14)\n      // Write the length of the calldata to `data`\n      mstore(add(calldataPointer, 0x60), dataLength)\n      // Copy the calldata to the buffer\n      calldatacopy(add(calldataPointer, 0x80), validateDataCalldataPointer, dataLength)\n      // Call the provider\n      if call(\n        gas(),\n        providerAddress,\n        0,\n        add(calldataPointer, 0x1c),\n        add(dataLength, 0x64),\n        0,\n        0x20\n      ) {\n        switch lt(returndatasize(), 0x20)\n        case 1 {\n          // If the returndata is invalid but the call succeeded, the call must throw\n          // because the validateCredential function is stateful and can have side effects.\n          mstore(0, invalidCredentialReturnedSelector)\n          revert(0x1c, 0x04)\n        }\n        default {\n          // If the return data is valid, set `credentialTimestamp` to the returned word\n          // with a uint32 mask applied\n          credentialTimestamp := and(mload(0), 0xffffffff)\n        }\n      }\n    }\n    // If the returned timestamp is null or greater than the current time, return false.\n    if (credentialTimestamp == 0 || credentialTimestamp > block.timestamp) {\n      return false;\n    }\n    // Check if the returned timestamp results in a valid expiry\n    if (provider.calculateExpiry(credentialTimestamp) >= block.timestamp) {\n      status.setCredential(provider, credentialTimestamp);\n      return true;\n    }\n  }\n\n  /// @dev Loops over all pull providers to find a valid credential for the lender.\n  function _loopTryGetCredential(\n    LenderStatus memory status,\n    address accountAddress,\n    uint256 pullProviderIndexToSkip\n  ) internal view returns (bool foundCredential) {\n    uint256 providerCount = _pullProviders.length;\n    for (uint256 i = 0; i < providerCount; i++) {\n      if (i == pullProviderIndexToSkip) continue;\n      RoleProvider provider = _pullProviders[i];\n      if (_tryGetCredential(status, provider, accountAddress)) return (true);\n    }\n  }\n\n  /**\n   * @dev Handles the hooks data passed to the contract.\n   *\n   *      If the hooks data is 20 bytes long, it is interpreted as a provider selection\n   *      to pull a credential from with `getCredential`.\n   *\n   *      If the hooks data is more than 20 bytes, it is interpreted as a request to use\n   *      `validateCredential`, where the first 20 bytes encode the provider address and\n   *      the remaining bytes are the encoded credential data to pass to the provider.\n   *\n   *      If the hooks data is less than 20 bytes, it is skipped.\n   *\n   * @param status Current lender status object, updated in memory if a credential is found\n   * @param accountAddress Address of the lender\n   * @param hooksData Bytes passed to the contract for provider selection\n   */\n  function _handleHooksData(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool validCredential) {\n    // Check if the hooks data only contains a provider address\n    if (hooksData.length == 20) {\n      // If the data contains only an address, attempt to query a credential from that provider\n      // if it exists and is a pull provider.\n      address providerAddress = _readAddress(hooksData);\n      RoleProvider provider = _roleProviders[providerAddress];\n      if (!provider.isNull() && provider.isPullProvider()) {\n        return _tryGetCredential(status, provider, accountAddress);\n      }\n    } else if (hooksData.length > 20) {\n      // If the data contains both an address and additional bytes, attempt to\n      // validate a credential from that provider\n      return _tryValidateCredential(status, accountAddress, hooksData);\n    }\n  }\n\n  /**\n   * @dev Internal function used to validate or update the status of a lender account for\n   *      hooks on restricted actions.\n   *\n   *     The function follows these steps until a valid credential is found:\n   *       1. Check if lender has an existing unexpired credential.\n   *       2. Check if `hooksData` was provided, and if so:\n   *         - If it contains only an address, call `getCredential` on that provider.\n   *         - If it contains an address and bytes, call `validateCredential` on that provider.\n   *       3. If lender has an existing expired credential, attempt to refresh it.\n   *       4. Loop over all pull providers to find a valid credential, excluding the last provider\n   *          if it failed to refresh.\n   *\n   * note: Does not update storage or emit an event, but is stateful because it can invoke\n   *       `validateCredential` on a provider.\n   */\n  function _tryValidateAccessInner(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool hasValidCredential, bool wasUpdated) {\n    // Get the last provider that granted the lender a credential, if any\n    RoleProvider lastProvider = status.hasCredential()\n      ? _roleProviders[status.lastProvider]\n      : EmptyRoleProvider;\n\n    // If the lender has an active credential and the last provider is still supported, return\n    if (!lastProvider.isNull() && status.credentialNotExpired(lastProvider)) {\n      return (true, false);\n    }\n\n    // Handle the calldata suffix, if any\n    if (_handleHooksData(status, accountAddress, hooksData)) {\n      return (true, true);\n    }\n\n    uint256 pullProviderIndexToSkip = type(uint256).max;\n\n    // If lender has an expired credential from a pull provider, attempt to refresh it\n    if (!lastProvider.isNull() && status.canRefresh) {\n      if (_tryGetCredential(status, lastProvider, accountAddress)) {\n        return (true, true);\n      }\n      // If refresh fails, provider should be skipped in the query loop\n      pullProviderIndexToSkip = lastProvider.pullProviderIndex();\n    }\n\n    // Loop over all pull providers to find a valid role for the lender\n    if (_loopTryGetCredential(status, accountAddress, pullProviderIndexToSkip)) {\n      return (true, true);\n    }\n\n    // If there was previously a credential and no valid credential could be found,\n    // unset the credential.\n    if (status.hasCredential()) {\n      status.unsetCredential();\n      wasUpdated = true;\n    }\n  }\n\n  function _tryValidateAccess(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool hasValidCredential) {\n    bool wasUpdated;\n    (hasValidCredential, wasUpdated) = _tryValidateAccessInner(status, accountAddress, hooksData);\n    if (wasUpdated) {\n      _lenderStatus[accountAddress] = status;\n      if (hasValidCredential) {\n        emit AccountAccessGranted(\n          status.lastProvider,\n          accountAddress,\n          status.lastApprovalTimestamp\n        );\n      } else {\n        emit AccountAccessRevoked(accountAddress);\n      }\n    }\n  }\n\n  function _setCredentialAndEmitAccessGranted(\n    LenderStatus memory status,\n    RoleProvider provider,\n    address accountAddress,\n    uint32 credentialTimestamp\n  ) internal {\n    // Update the account's status with the new credential in memory\n    status.setCredential(provider, credentialTimestamp);\n    // Update the account's status in storage\n    _lenderStatus[accountAddress] = status;\n    emit AccountAccessGranted(provider.providerAddress(), accountAddress, credentialTimestamp);\n  }\n\n  // ========================================================================== //\n  //                                    Hooks                                   //\n  // ========================================================================== //\n\n  function onDeposit(\n    address lender,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n    if (!hookedMarkets[msg.sender]) {\n      revert NotHookedMarket();\n    }\n    // Retrieve the lender's status from storage\n    LenderStatus memory status = _lenderStatus[lender];\n    // Check that the lender is not blocked\n    if (status.isBlockedFromDeposits) {\n      revert NotApprovedLender();\n    }\n\n    // Attempt to validate the lender's access\n    // Uses the inner method here as storage may need to be updated if this\n    // is their first deposit\n    (bool hasValidCredential, bool roleUpdated) = _tryValidateAccessInner(\n      status,\n      lender,\n      hooksData\n    );\n    if (!hasValidCredential) {\n      revert NotApprovedLender();\n    }\n\n    bool depositStatusUpdated = !status.hasEverDeposited;\n\n    // If the lender has never deposited before, emit an event\n    if (depositStatusUpdated) {\n      emit AccountMadeFirstDeposit(lender);\n      status.hasEverDeposited = true;\n    }\n\n    // If the lender's role was updated, emit an event\n    if (roleUpdated) {\n      emit AccountAccessGranted(status.lastProvider, lender, status.lastApprovalTimestamp);\n    }\n\n    // Update the lender's status in storage if role or deposit status was updated\n    if (depositStatusUpdated.or(roleUpdated)) {\n      _lenderStatus[lender] = status;\n    }\n  }\n\n  /**\n   * @dev Called when a lender attempts to queue a withdrawal.\n   *      Passes the check if the lender has either deposited before or\n   *      has a valid credential from a role provider.\n   */\n  function onQueueWithdrawal(\n    address lender,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n    LenderStatus memory status = _lenderStatus[lender];\n    if (!status.hasEverDeposited && !_tryValidateAccess(status, lender, hooksData)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  function onExecuteWithdrawal(\n    address lender,\n    uint128 /* normalizedAmountWithdrawn */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {}\n\n  function onTransfer(\n    address /* caller */,\n    address /* from */,\n    address to,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata /* extraData */\n  ) external override {\n    LenderStatus memory toStatus = _lenderStatus[to];\n    if (toStatus.isBlockedFromDeposits) revert NotApprovedLender();\n  }\n\n  function onBorrow(\n    uint /* normalizedAmount */,\n    MarketState calldata /* state */,\n    bytes calldata /* extraData */\n  ) external override {}\n\n  function onRepay(\n    uint normalizedAmount,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {}\n\n  function onCloseMarket(MarketState calldata state, bytes calldata hooksData) external override {}\n\n  function onAssetsSentToEscrow(\n    address lender,\n    address asset,\n    address escrow,\n    uint scaledAmount,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {}\n\n  function onSetMaxTotalSupply(\n    uint256 maxTotalSupply,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {}\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState calldata intermediateState,\n    bytes calldata hooksData\n  )\n    public\n    virtual\n    override\n    returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips)\n  {\n    return\n      super.onSetAnnualInterestAndReserveRatioBips(\n        annualInterestBips,\n        reserveRatioBips,\n        intermediateState,\n        hooksData\n      );\n  }\n}\n"},"src/libraries/BoolUtils.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nlibrary BoolUtils {\n  function and(bool a, bool b) internal pure returns (bool c) {\n    assembly {\n      c := and(a, b)\n    }\n  }\n\n  function or(bool a, bool b) internal pure returns (bool c) {\n    assembly {\n      c := or(a, b)\n    }\n  }\n\n  function xor(bool a, bool b) internal pure returns (bool c) {\n    assembly {\n      c := xor(a, b)\n    }\n  }\n}\n"},"src/libraries/MathUtils.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './Errors.sol';\n\nuint256 constant BIP = 1e4;\nuint256 constant HALF_BIP = 0.5e4;\n\nuint256 constant RAY = 1e27;\nuint256 constant HALF_RAY = 0.5e27;\n\nuint256 constant BIP_RAY_RATIO = 1e23;\n\nuint256 constant SECONDS_IN_365_DAYS = 365 days;\n\nlibrary MathUtils {\n  /// @dev The multiply-divide operation failed, either due to a\n  /// multiplication overflow, or a division by a zero.\n  error MulDivFailed();\n\n  using MathUtils for uint256;\n\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   *\n   * @param rateBip The interest rate, in bips\n   * @param timeDelta The time elapsed since the last interest accrual\n   * @return result The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterestFromBips(\n    uint256 rateBip,\n    uint256 timeDelta\n  ) internal pure returns (uint256 result) {\n    uint256 rate = rateBip.bipToRay();\n    uint256 accumulatedInterestRay = rate * timeDelta;\n    unchecked {\n      return accumulatedInterestRay / SECONDS_IN_365_DAYS;\n    }\n  }\n\n  /**\n   * @dev Return the smaller of `a` and `b`\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = ternary(a < b, a, b);\n  }\n\n  /**\n   * @dev Return the larger of `a` and `b`.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = ternary(a < b, b, a);\n  }\n\n  /**\n   * @dev Saturation subtraction. Subtract `b` from `a` and return the result\n   *      if it is positive or zero if it underflows.\n   */\n  function satSub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // (a > b) * (a - b)\n      // If a-b underflows, the product will be zero\n      c := mul(gt(a, b), sub(a, b))\n    }\n  }\n\n  /**\n   * @dev Saturation addition. Add `a` to `b` and return the result\n   *      if it is less than `maxValue` or `maxValue` if it overflows.\n   */\n  function satAdd(uint256 a, uint256 b, uint256 maxValue) internal pure returns (uint256 c) {\n    unchecked {\n      c = a + b;\n      return ternary(c < maxValue, c, maxValue);\n    }\n  }\n\n  /**\n   * @dev Return `valueIfTrue` if `condition` is true and `valueIfFalse` if it is false.\n   *      Equivalent to `condition ? valueIfTrue : valueIfFalse`\n   */\n  function ternary(\n    bool condition,\n    uint256 valueIfTrue,\n    uint256 valueIfFalse\n  ) internal pure returns (uint256 c) {\n    assembly {\n      c := add(valueIfFalse, mul(condition, sub(valueIfTrue, valueIfFalse)))\n    }\n  }\n\n  /**\n   * @dev Multiplies two bip, rounding half up to the nearest bip\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function bipMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b == 0 || a <= (type(uint256).max - HALF_BIP) / b)`\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_BIP), b))))) {\n        // Store the Panic error signature.\n        mstore(0, Panic_ErrorSelector)\n        // Store the arithmetic (0x11) panic code.\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, b), HALF_BIP), BIP)\n    }\n  }\n\n  /**\n   * @dev Divides two bip, rounding half up to the nearest bip\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function bipDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b != 0 && a <= (type(uint256).max - b/2) / BIP)`\n      if or(iszero(b), gt(a, div(sub(not(0), div(b, 2)), BIP))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, BIP), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Converts bip up to ray\n   */\n  function bipToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/BIP_RAY_RATIO == a\n    assembly {\n      b := mul(a, BIP_RAY_RATIO)\n      // equivalent to `require((b = a * BIP_RAY_RATIO) / BIP_RAY_RATIO == a )\n      if iszero(eq(div(b, BIP_RAY_RATIO), a)) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n    }\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b == 0 || a <= (type(uint256).max - HALF_RAY) / b)`\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @dev Divide two ray, rounding half up to the nearest ray\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b != 0 && a <= (type(uint256).max - halfB) / RAY)`\n      if or(iszero(b), gt(a, div(sub(not(0), div(b, 2)), RAY))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Returns `floor(x * y / d)`.\n   *      Reverts if `x * y` overflows, or `d` is zero.\n   * @custom:author solady/src/utils/FixedPointMathLib.sol\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n    assembly {\n      // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n        // Store the function selector of `MulDivFailed()`.\n        mstore(0x00, 0xad251c27)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := div(mul(x, y), d)\n    }\n  }\n\n  /**\n   * @dev Returns `ceil(x * y / d)`.\n   *      Reverts if `x * y` overflows, or `d` is zero.\n   * @custom:author solady/src/utils/FixedPointMathLib.sol\n   */\n  function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n    assembly {\n      // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n        // Store the function selector of `MulDivFailed()`.\n        mstore(0x00, 0xad251c27)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n    }\n  }\n}\n"},"src/types/RoleProvider.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport '../libraries/MathUtils.sol';\n\ntype RoleProvider is uint256;\nuint24 constant NotPullProviderIndex = type(uint24).max;\nRoleProvider constant EmptyRoleProvider = RoleProvider.wrap(0);\n\nusing LibRoleProvider for RoleProvider global;\n\n/**\n * @dev Create a `RoleProvider` from its members.\n */\nfunction encodeRoleProvider(\n  uint32 timeToLive,\n  address providerAddress,\n  uint24 pullProviderIndex\n) pure returns (RoleProvider provider) {\n  assembly {\n    provider := or(\n      or(shl(0xe0, timeToLive), shl(0x40, providerAddress)),\n      shl(0x28, pullProviderIndex)\n    )\n  }\n}\n\n\nlibrary LibRoleProvider {\n  using MathUtils for uint256;\n\n  /**\n   * @dev Calculate the expiry for a credential granted at `timestamp` by `provider`,\n   *      adding its time-to-live to the timestamp and maxing out at the max uint32,\n   *      indicating indefinite access.\n   */\n  function calculateExpiry(\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure returns (uint256) {\n    return timestamp.satAdd(provider.timeToLive(), type(uint32).max);\n  }\n\n  /// @dev Extract `timeToLive, providerAddress, pullProviderIndex` from a RoleProvider\n  function decodeRoleProvider(\n    RoleProvider provider\n  )\n    internal\n    pure\n    returns (uint32 _timeToLive, address _providerAddress, uint24 _pullProviderIndex)\n  {\n    assembly {\n      _timeToLive := shr(0xe0, provider)\n      _providerAddress := shr(0x60, shl(0x20, provider))\n      _pullProviderIndex := shr(0xe8, shl(0xc0, provider))\n    }\n  }\n\n  /// @dev Extract `timeToLive` from `provider`\n  function timeToLive(RoleProvider provider) internal pure returns (uint32 _timeToLive) {\n    assembly {\n      _timeToLive := shr(0xe0, provider)\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `timeToLive` set to `_timeToLive`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setTimeToLive(\n    RoleProvider provider,\n    uint32 _timeToLive\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(shr(0x20, shl(0x20, provider)), shl(0xe0, _timeToLive))\n    }\n  }\n\n  /// @dev Extract `providerAddress` from `provider`\n  function providerAddress(RoleProvider provider) internal pure returns (address _providerAddress) {\n    assembly {\n      _providerAddress := shr(0x60, shl(0x20, provider))\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `providerAddress` set to `_providerAddress`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setProviderAddress(\n    RoleProvider provider,\n    address _providerAddress\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(\n        and(provider, 0xffffffff0000000000000000000000000000000000000000ffffffffffffffff),\n        shl(0x40, _providerAddress)\n      )\n    }\n  }\n\n  /// @dev Extract `pullProviderIndex` from `provider`\n  function pullProviderIndex(\n    RoleProvider provider\n  ) internal pure returns (uint24 _pullProviderIndex) {\n    assembly {\n      _pullProviderIndex := shr(0xe8, shl(0xc0, provider))\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `pullProviderIndex` set to `_pullProviderIndex`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setPullProviderIndex(\n    RoleProvider provider,\n    uint24 _pullProviderIndex\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(\n        and(provider, 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff),\n        shl(0x28, _pullProviderIndex)\n      )\n    }\n  }\n\n  /// @dev Checks if two RoleProviders are equal\n  function eq(\n    RoleProvider provider,\n    RoleProvider otherRoleProvider\n  ) internal pure returns (bool _eq) {\n    assembly {\n      _eq := eq(provider, otherRoleProvider)\n    }\n  }\n\n  /// @dev Checks if `provider` is null\n  function isNull(RoleProvider provider) internal pure returns (bool _null) {\n    assembly {\n      _null := iszero(provider)\n    }\n  }\n\n  /**\n   * @dev Returns whether `provider` is a pull provider by checking if\n   *      `pullProviderIndex` is not equal to `NotPullProviderIndex`.\n   */\n  function isPullProvider(RoleProvider provider) internal pure returns (bool) {\n    return provider.pullProviderIndex() != NotPullProviderIndex;\n  }\n\n  /**\n   * @dev Set `pullProviderIndex` in `provider` to `NotPullProviderIndex`\n   *      to mark it as not a pull provider.\n   */\n  function setNotPullProvider(\n    RoleProvider provider\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(provider, 0xffffff0000000000)\n    }\n  }\n}\n"},"src/types/LenderStatus.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\nimport './RoleProvider.sol';\n\n/**\n * @param isBlockedFromDeposits Whether the lender is blocked from depositing\n * @param hasEverDeposited Whether the lender has ever deposited to the market\n * @param lastProvider The address of the last provider to grant the lender a credential\n * @param canRefresh Whether the last provider can refresh the lender's credential\n * @param lastApprovalTimestamp The timestamp at which the lender's credential was granted\n */\nstruct LenderStatus {\n  bool isBlockedFromDeposits;\n  bool hasEverDeposited;\n  address lastProvider;\n  bool canRefresh;\n  uint32 lastApprovalTimestamp;\n}\n\nusing LibLenderStatus for LenderStatus global;\n\nlibrary LibLenderStatus {\n  /**\n   * @dev Returns whether the lender's credential has expired.\n   *\n   *      Note: Does not check if the lender has a credential - if the\n   *      provider's TTL is greater than the current block timestamp,\n   *      this function will always return false. Should always be used\n   *      in conjunction with `hasCredential`.\n   */\n  function credentialExpired(\n    LenderStatus memory status,\n    RoleProvider provider\n  ) internal view returns (bool) {\n    return provider.calculateExpiry(status.lastApprovalTimestamp) < block.timestamp;\n  }\n\n  function hasCredential(LenderStatus memory status) internal pure returns (bool) {\n    return status.lastApprovalTimestamp > 0;\n  }\n\n  /**\n    * @dev Returns whether the lender's credential has not expired.\n   *\n   *      Note: Does not check if the lender has a credential - if the\n   *      provider's TTL is greater than the current block timestamp,\n   *      this function will always return true. Should always be used\n   *      in conjunction with `hasCredential`.\n   */\n  function credentialNotExpired(\n    LenderStatus memory status,\n    RoleProvider provider\n  ) internal view returns (bool) {\n    return provider.calculateExpiry(status.lastApprovalTimestamp) >= block.timestamp;\n  }\n\n  function setCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure {\n    // User is approved, update status with new expiry and last provider\n    status.lastApprovalTimestamp = uint32(timestamp);\n    status.lastProvider = provider.providerAddress();\n    status.canRefresh = provider.isPullProvider();\n  }\n\n  function unsetCredential(LenderStatus memory status) internal pure {\n    status.canRefresh = false;\n    status.lastApprovalTimestamp = 0;\n    status.lastProvider = address(0);\n  }\n}\n"},"src/access/IRoleProvider.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\ninterface IRoleProvider {\n  function isPullProvider() external view returns (bool);\n\n  function getCredential(address account) external view returns (uint32 timestamp);\n\n  /**\n   * @dev Validate a credential (e.g. a signature from an access token granter) for an account.\n   * @param account The account to validate the credential for.\n   * @param data The data to validate the credential with.\n   * @return timestamp The timestamp at which the credential was granted.\n   */\n  function validateCredential(address account, bytes calldata data) external returns (uint32 timestamp);\n}\n"},"src/access/MarketConstraintHooks.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './IHooks.sol';\nimport '../libraries/BoolUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint16 originalAnnualInterestBips;\n  uint16 originalReserveRatioBips;\n  uint32 expiry;\n}\n\nabstract contract MarketConstraintHooks is IHooks {\n  using BoolUtils for bool;\n\n  error DelinquencyGracePeriodOutOfBounds();\n  error ReserveRatioBipsOutOfBounds();\n  error DelinquencyFeeBipsOutOfBounds();\n  error WithdrawalBatchDurationOutOfBounds();\n  error AnnualInterestBipsOutOfBounds();\n\n  event TemporaryExcessReserveRatioActivated(\n    address indexed market,\n    uint256 originalReserveRatioBips,\n    uint256 temporaryReserveRatioBips,\n    uint256 temporaryReserveRatioExpiry\n  );\n\n  event TemporaryExcessReserveRatioUpdated(\n    address indexed market,\n    uint256 originalReserveRatioBips,\n    uint256 temporaryReserveRatioBips,\n    uint256 temporaryReserveRatioExpiry\n  );\n\n  event TemporaryExcessReserveRatioCanceled(address indexed market);\n\n  event TemporaryExcessReserveRatioExpired(address indexed market);\n\n  uint32 internal constant MinimumDelinquencyGracePeriod = 0;\n  uint32 internal constant MaximumDelinquencyGracePeriod = 90 days;\n\n  uint16 internal constant MinimumReserveRatioBips = 0;\n  uint16 internal constant MaximumReserveRatioBips = 10_000;\n\n  uint16 internal constant MinimumDelinquencyFeeBips = 0;\n  uint16 internal constant MaximumDelinquencyFeeBips = 10_000;\n\n  uint32 internal constant MinimumWithdrawalBatchDuration = 0;\n  uint32 internal constant MaximumWithdrawalBatchDuration = 365 days;\n\n  uint16 internal constant MinimumAnnualInterestBips = 0;\n  uint16 internal constant MaximumAnnualInterestBips = 10_000;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    pure\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  function _onCreateMarket(\n    address /* deployer */,\n    address /* marketAddress */,\n    DeployMarketInputs calldata parameters,\n    bytes calldata /* extraData */\n  ) internal virtual override {\n    enforceParameterConstraints(\n      parameters.annualInterestBips,\n      parameters.delinquencyFeeBips,\n      parameters.withdrawalBatchDuration,\n      parameters.reserveRatioBips,\n      parameters.delinquencyGracePeriod\n    );\n  }\n\n  /**\n   * @dev Returns the new temporary reserve ratio for a given interest rate\n   *      change. This is calculated as no change if the rate change is LEQ\n   *      a 25% decrease, otherwise double the relative difference between\n   *      the old and new APR rates (in bips), bounded to a maximum of 100%.\n   *      If this value is lower than the existing reserve ratio, the existing\n   *      reserve ratio is returned instead.\n   */\n  function _calculateTemporaryReserveRatioBips(\n    uint256 annualInterestBips,\n    uint256 originalAnnualInterestBips,\n    uint256 originalReserveRatioBips\n  ) internal pure returns (uint16 temporaryReserveRatioBips) {\n    // Calculate the relative reduction in the interest rate in bips,\n    // bound to a maximum of 100%\n    uint256 relativeDiff = MathUtils.mulDiv(\n      10000,\n      originalAnnualInterestBips - annualInterestBips,\n      originalAnnualInterestBips\n    );\n\n    // If the reduction is 25% (2500 bips) or less, return the original reserve ratio\n    if (relativeDiff <= 2500) {\n      temporaryReserveRatioBips = uint16(originalReserveRatioBips);\n    } else {\n      // Calculate double the relative reduction in the interest rate in bips,\n      // bound to a maximum of 100%\n      uint256 boundRelativeDiff = MathUtils.min(10000, 2 * relativeDiff);\n\n      // If the bound relative diff is lower than the existing reserve ratio, return the latter.\n      temporaryReserveRatioBips = uint16(\n        MathUtils.max(boundRelativeDiff, originalReserveRatioBips)\n      );\n    }\n  }\n\n  /**\n   * @dev Hook to enforce constraints on changes to the annual interest rate\n   *      and reserve ratio. Reducing the APR triggers an update period of two weeks,\n   *      during which the market's reserve ratio is temporarily increased proportionally\n   *      to the reduction. The original APR is pegged to the previous value during this\n   *      time to prevent abuse of the allowed 25% unpenalized reduction.\n   *\n   * @param annualInterestBips The new annual interest rate in bips provided by the borrower.\n   * @param {} Unused parameter for the reserve ratio bips provided by the borrower.\n   * @param intermediateState The current state of the market.\n   * @param {} Unused parameter for extra data.\n   *\n   * @return newAnnualInterestBips The new annual interest rate in bips to be set.\n   *                               always equal to the input parameter.\n   * @return newReserveRatioBips The new reserve ratio in bips to be set.\n   */\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 /* reserveRatioBips */,\n    MarketState calldata intermediateState,\n    bytes calldata /* extraData */\n  ) public virtual override returns (uint16 newAnnualInterestBips, uint16 newReserveRatioBips) {\n    (newAnnualInterestBips, newReserveRatioBips) = (\n      annualInterestBips,\n      intermediateState.reserveRatioBips\n    );\n    address market = msg.sender;\n\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n\n    // Get the existing temporary reserve ratio from storage, if any\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n\n    if (tmp.expiry > 0) {\n      bool canExpire = (annualInterestBips >= intermediateState.annualInterestBips).and(\n        block.timestamp >= tmp.expiry\n      );\n      bool canCancel = annualInterestBips >= tmp.originalAnnualInterestBips;\n      if (canExpire.or(canCancel)) {\n        // If the update period has expired and the provided value doesn't reduce it further,\n        // or it is not expired but the new value undoes the reduction for the current update\n        // period, reset the temporary reserve ratio.\n        if (canExpire) {\n          emit TemporaryExcessReserveRatioExpired(market);\n        } else {\n          emit TemporaryExcessReserveRatioCanceled(market);\n        }\n        delete temporaryExcessReserveRatio[market];\n        return (newAnnualInterestBips, tmp.originalReserveRatioBips);\n      }\n    }\n\n    // Get the original values for the ongoing or newly created update period.\n    (uint16 originalAnnualInterestBips, uint16 originalReserveRatioBips) = tmp.expiry == 0\n      ? (intermediateState.annualInterestBips, intermediateState.reserveRatioBips)\n      : (tmp.originalAnnualInterestBips, tmp.originalReserveRatioBips);\n\n    if (annualInterestBips < originalAnnualInterestBips) {\n      // If the new interest rate is lower than the original, calculate a temporarily\n      // increased reserve ratio as:\n      // relativeReduction <= 0.25 ? originalReserveRatio : max(originalReserveRatio, min(2 * relativeReduction, 100%))\n      uint16 temporaryReserveRatioBips = _calculateTemporaryReserveRatioBips(\n        annualInterestBips,\n        originalAnnualInterestBips,\n        originalReserveRatioBips\n      );\n      uint32 expiry = uint32(block.timestamp + 2 weeks);\n      if (tmp.expiry == 0) {\n        // If there is no existing temporary reserve ratio, store the current\n        // interest rate and reserve ratio as the original values.\n        emit TemporaryExcessReserveRatioActivated(\n          market,\n          originalReserveRatioBips,\n          temporaryReserveRatioBips,\n          expiry\n        );\n        tmp.originalAnnualInterestBips = originalAnnualInterestBips;\n        tmp.originalReserveRatioBips = originalReserveRatioBips;\n      } else {\n        // If the new APR is lower than the original but higher than the current rate,\n        // update the reserve ratio but leave the previous expiry; otherwise, reset the timer.\n        if (annualInterestBips >= intermediateState.annualInterestBips) {\n          expiry = tmp.expiry;\n        }\n        emit TemporaryExcessReserveRatioUpdated(\n          market,\n          originalReserveRatioBips,\n          temporaryReserveRatioBips,\n          expiry\n        );\n      }\n      tmp.expiry = expiry;\n      temporaryExcessReserveRatio[market] = tmp;\n      newReserveRatioBips = temporaryReserveRatioBips;\n    }\n  }\n}\n"},"src/libraries/Errors.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nuint256 constant Panic_CompilerPanic = 0x00;\nuint256 constant Panic_AssertFalse = 0x01;\nuint256 constant Panic_Arithmetic = 0x11;\nuint256 constant Panic_DivideByZero = 0x12;\nuint256 constant Panic_InvalidEnumValue = 0x21;\nuint256 constant Panic_InvalidStorageByteArray = 0x22;\nuint256 constant Panic_EmptyArrayPop = 0x31;\nuint256 constant Panic_ArrayOutOfBounds = 0x32;\nuint256 constant Panic_MemoryTooLarge = 0x41;\nuint256 constant Panic_UninitializedFunctionPointer = 0x51;\n\nuint256 constant Panic_ErrorSelector = 0x4e487b71;\nuint256 constant Panic_ErrorCodePointer = 0x20;\nuint256 constant Panic_ErrorLength = 0x24;\nuint256 constant Error_SelectorPointer = 0x1c;\n\n/**\n * @dev Reverts with the given error selector.\n * @param errorSelector The left-aligned error selector.\n */\nfunction revertWithSelector(bytes4 errorSelector) pure {\n  assembly {\n    mstore(0, errorSelector)\n    revert(0, 4)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector.\n * @param errorSelector The left-padded error selector.\n */\nfunction revertWithSelector(uint256 errorSelector) pure {\n  assembly {\n    mstore(0, errorSelector)\n    revert(Error_SelectorPointer, 4)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector and argument.\n * @param errorSelector The left-aligned error selector.\n * @param argument The argument to the error.\n */\nfunction revertWithSelectorAndArgument(bytes4 errorSelector, uint256 argument) pure {\n  assembly {\n    mstore(0, errorSelector)\n    mstore(4, argument)\n    revert(0, 0x24)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector and argument.\n * @param errorSelector The left-padded error selector.\n * @param argument The argument to the error.\n */\nfunction revertWithSelectorAndArgument(uint256 errorSelector, uint256 argument) pure {\n  assembly {\n    mstore(0, errorSelector)\n    mstore(0x20, argument)\n    revert(Error_SelectorPointer, 0x24)\n  }\n}\n"},"src/access/IHooks.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport '../types/HooksConfig.sol';\nimport '../libraries/MarketState.sol';\nimport '../interfaces/WildcatStructsAndEnums.sol';\n\nabstract contract IHooks {\n  error CallerNotFactory();\n\n  address public immutable factory;\n\n  constructor() {\n    factory = msg.sender;\n  }\n\n  /// @dev Returns the version string of the hooks contract.\n  ///      Used to determine what the contract does and how `extraData` is interpreted.\n  function version() external view virtual returns (string memory);\n\n  /// @dev Returns the HooksDeploymentConfig type which contains the sets\n  ///      of optional and required hooks that this contract implements.\n  function config() external view virtual returns (HooksDeploymentConfig);\n\n  function onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata extraData\n  ) external {\n    if (msg.sender != factory) revert CallerNotFactory();\n    _onCreateMarket(deployer, marketAddress, parameters, extraData);\n  }\n\n  function _onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata extraData\n  ) internal virtual;\n\n  function onDeposit(\n    address lender,\n    uint256 scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onQueueWithdrawal(\n    address lender,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onExecuteWithdrawal(\n    address lender,\n    uint128 normalizedAmountWithdrawn,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onTransfer(\n    address caller,\n    address from,\n    address to,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onBorrow(\n    uint normalizedAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onRepay(\n    uint normalizedAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onCloseMarket(\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onAssetsSentToEscrow(\n    address lender,\n    address asset,\n    address escrow,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onSetMaxTotalSupply(\n    uint256 maxTotalSupply,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips);\n}\n"},"src/types/HooksConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../access/IHooks.sol';\nimport '../libraries/MarketState.sol';\n\ntype HooksConfig is uint256;\n\nHooksConfig constant EmptyHooksConfig = HooksConfig.wrap(0);\n\nusing LibHooksConfig for HooksConfig global;\nusing LibHooksConfig for HooksDeploymentConfig global;\n\n// Type that contains only the flags for a specific hooks contract, with one\n// set of flags for optional hooks and one set of flags for required hooks.\ntype HooksDeploymentConfig is uint256;\n\nfunction encodeHooksDeploymentConfig(\n  HooksConfig optionalFlags,\n  HooksConfig requiredFlags\n) pure returns (HooksDeploymentConfig flags) {\n  assembly {\n    let cleanedOptionalFlags := and(0xffff, shr(0x50, optionalFlags))\n    let cleanedRequiredFlags := and(0xffff0000, shr(0x40, requiredFlags))\n    flags := or(cleanedOptionalFlags, cleanedRequiredFlags)\n  }\n}\n\n// --------------------- Bits after hook activation flag -------------------- //\n\n// Offsets are from the right\n\nuint256 constant Bit_Enabled_Deposit = 95;\nuint256 constant Bit_Enabled_QueueWithdrawal = 94;\nuint256 constant Bit_Enabled_ExecuteWithdrawal = 93;\nuint256 constant Bit_Enabled_Transfer = 92;\nuint256 constant Bit_Enabled_Borrow = 91;\nuint256 constant Bit_Enabled_Repay = 90;\nuint256 constant Bit_Enabled_CloseMarket = 89;\nuint256 constant Bit_Enabled_AssetsSentToEscrow = 88;\nuint256 constant Bit_Enabled_SetMaxTotalSupply = 87;\nuint256 constant Bit_Enabled_SetAnnualInterestAndReserveRatioBips = 86;\n\nuint256 constant MarketStateSize = 0x01a0;\n\nfunction encodeHooksConfig(\n  address hooksAddress,\n  bool useOnDeposit,\n  bool useOnQueueWithdrawal,\n  bool useOnExecuteWithdrawal,\n  bool useOnTransfer,\n  bool useOnBorrow,\n  bool useOnRepay,\n  bool useOnCloseMarket,\n  bool useOnAssetsSentToEscrow,\n  bool useOnSetMaxTotalSupply,\n  bool useOnSetAnnualInterestAndReserveRatioBips\n) pure returns (HooksConfig hooks) {\n  assembly {\n    hooks := shl(96, hooksAddress)\n    hooks := or(hooks, shl(Bit_Enabled_Deposit, useOnDeposit))\n    hooks := or(hooks, shl(Bit_Enabled_QueueWithdrawal, useOnQueueWithdrawal))\n    hooks := or(hooks, shl(Bit_Enabled_ExecuteWithdrawal, useOnExecuteWithdrawal))\n    hooks := or(hooks, shl(Bit_Enabled_Transfer, useOnTransfer))\n    hooks := or(hooks, shl(Bit_Enabled_Borrow, useOnBorrow))\n    hooks := or(hooks, shl(Bit_Enabled_Repay, useOnRepay))\n    hooks := or(hooks, shl(Bit_Enabled_CloseMarket, useOnCloseMarket))\n    hooks := or(hooks, shl(Bit_Enabled_AssetsSentToEscrow, useOnAssetsSentToEscrow))\n    hooks := or(hooks, shl(Bit_Enabled_SetMaxTotalSupply, useOnSetMaxTotalSupply))\n    hooks := or(\n      hooks,\n      shl(\n        Bit_Enabled_SetAnnualInterestAndReserveRatioBips,\n        useOnSetAnnualInterestAndReserveRatioBips\n      )\n    )\n  }\n}\n\nlibrary LibHooksConfig {\n  function setHooksAddress(\n    HooksConfig hooks,\n    address _hooksAddress\n  ) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      // Shift twice to clear the address\n      updatedHooks := shr(96, shl(96, hooks))\n      // Set the new address\n      updatedHooks := or(updatedHooks, shl(96, _hooksAddress))\n    }\n  }\n\n  /**\n   * @dev Create a merged HooksConfig with the shared flags of `a` and `b`\n   *      and the address of `a`.\n   */\n  function mergeSharedFlags(\n    HooksConfig a,\n    HooksConfig b\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let addressA := shl(0x60, shr(0x60, a))\n      let flagsA := shl(0xa0, a)\n      let flagsB := shl(0xa0, b)\n      let mergedFlags := shr(0xa0, and(flagsA, flagsB))\n      merged := or(addressA, mergedFlags)\n    }\n  }\n\n  /**\n   * @dev Create a merged HooksConfig with the shared flags of `a` and `b`\n   *      and the address of `a`.\n   */\n  function mergeAllFlags(\n    HooksConfig a,\n    HooksConfig b\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let addressA := shl(0x60, shr(0x60, a))\n      let flagsA := shl(0xa0, a)\n      let flagsB := shl(0xa0, b)\n      let mergedFlags := shr(0xa0, or(flagsA, flagsB))\n      merged := or(addressA, mergedFlags)\n    }\n  }\n\n  function mergeFlags(\n    HooksConfig config,\n    HooksDeploymentConfig flags\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let _hooksAddress := shl(96, shr(96, config))\n      // Position flags at the end of the word\n      let configFlags := shr(0x50, config)\n      // Optional flags are already in the right position, required flags must be\n      // shifted to align with the other flags. The leading and trailing bits for all 3\n      // words will be masked out at the end\n      let _optionalFlags := flags\n      let _requiredFlags := shr(0x10, flags)\n      let mergedFlags := and(0xffff, or(and(configFlags, _optionalFlags), _requiredFlags))\n\n      merged := or(_hooksAddress, shl(0x50, mergedFlags))\n    }\n  }\n\n  function optionalFlags(HooksDeploymentConfig flags) internal pure returns (HooksConfig config) {\n    assembly {\n      config := shl(0x50, and(flags, 0xffff))\n    }\n  }\n\n  function requiredFlags(HooksDeploymentConfig flags) internal pure returns (HooksConfig config) {\n    assembly {\n      config := shl(0x40, and(flags, 0xffff0000))\n    }\n  }\n\n  // ========================================================================== //\n  //                              Parameter Readers                             //\n  // ========================================================================== //\n\n  function readFlag(HooksConfig hooks, uint256 bitsAfter) internal pure returns (bool flagged) {\n    assembly {\n      flagged := and(shr(bitsAfter, hooks), 1)\n    }\n  }\n\n  function setFlag(HooksConfig hooks, uint256 bitsAfter) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      updatedHooks := or(hooks, shl(bitsAfter, 1))\n    }\n  }\n\n  /// @dev Address of the hooks contract\n  function hooksAddress(HooksConfig hooks) internal pure returns (address _hooks) {\n    assembly {\n      _hooks := shr(96, hooks)\n    }\n  }\n\n  /// @dev Whether to call hook contract for deposit\n  function useOnDeposit(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Deposit);\n  }\n\n  /// @dev Whether to call hook contract for queueWithdrawal\n  function useOnQueueWithdrawal(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_QueueWithdrawal);\n  }\n\n  /// @dev Whether to call hook contract for executeWithdrawal\n  function useOnExecuteWithdrawal(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_ExecuteWithdrawal);\n  }\n\n  /// @dev Whether to call hook contract for transfer\n  function useOnTransfer(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Transfer);\n  }\n\n  /// @dev Whether to call hook contract for borrow\n  function useOnBorrow(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Borrow);\n  }\n\n  /// @dev Whether to call hook contract for repay\n  function useOnRepay(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Repay);\n  }\n\n  /// @dev Whether to call hook contract for closeMarket\n  function useOnCloseMarket(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_CloseMarket);\n  }\n\n  /// @dev Whether to call hook contract when account sanctioned\n  function useOnAssetsSentToEscrow(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_AssetsSentToEscrow);\n  }\n\n  /// @dev Whether to call hook contract for setMaxTotalSupply\n  function useOnSetMaxTotalSupply(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetMaxTotalSupply);\n  }\n\n  /// @dev Whether to call hook contract for setAnnualInterestAndReserveRatioBips\n  function useOnSetAnnualInterestAndReserveRatioBips(\n    HooksConfig hooks\n  ) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetAnnualInterestAndReserveRatioBips);\n  }\n\n  // ========================================================================== //\n  //                              Hook for deposit                              //\n  // ========================================================================== //\n\n  uint256 internal constant DepositCalldataSize = 0x24;\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant DepositHook_Base_Size = 0x0224;\n  uint256 internal constant DepositHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant DepositHook_State_Offset = 0x40;\n  uint256 internal constant DepositHook_ExtraData_Head_Offset = 0x1e0;\n  uint256 internal constant DepositHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant DepositHook_ExtraData_TailOffset = 0x0220;\n\n  function onDeposit(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onDepositSelector = uint32(IHooks.onDeposit.selector);\n    if (self.useOnDeposit()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), DepositCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onDeposit`\n        mstore(cdPointer, onDepositSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, DepositHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, DepositHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, DepositHook_ExtraData_Head_Offset),\n          DepositHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, DepositHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, DepositHook_ExtraData_TailOffset),\n          DepositCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(DepositHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                          Hook for queueWithdrawal                          //\n  // ========================================================================== //\n\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant QueueWithdrawalHook_Base_Size = 0x0224;\n  uint256 internal constant QueueWithdrawalHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant QueueWithdrawalHook_State_Offset = 0x40;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_Head_Offset = 0x1e0;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_TailOffset = 0x0220;\n\n  function onQueueWithdrawal(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onQueueWithdrawalSelector = uint32(IHooks.onQueueWithdrawal.selector);\n    if (self.useOnQueueWithdrawal()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onQueueWithdrawal`\n        mstore(cdPointer, onQueueWithdrawalSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, QueueWithdrawalHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, QueueWithdrawalHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, QueueWithdrawalHook_ExtraData_Head_Offset),\n          QueueWithdrawalHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, QueueWithdrawalHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, QueueWithdrawalHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(QueueWithdrawalHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                         Hook for executeWithdrawal                         //\n  // ========================================================================== //\n\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant ExecuteWithdrawalHook_Base_Size = 0x0224;\n  uint256 internal constant ExecuteWithdrawalHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant ExecuteWithdrawalHook_State_Offset = 0x40;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_Head_Offset = 0x1e0;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_TailOffset = 0x0220;\n\n  function onExecuteWithdrawal(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onExecuteWithdrawalSelector = uint32(IHooks.onExecuteWithdrawal.selector);\n    if (self.useOnExecuteWithdrawal()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onExecuteWithdrawal`\n        mstore(cdPointer, onExecuteWithdrawalSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, ExecuteWithdrawalHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, ExecuteWithdrawalHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, ExecuteWithdrawalHook_ExtraData_Head_Offset),\n          ExecuteWithdrawalHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, ExecuteWithdrawalHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, ExecuteWithdrawalHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(ExecuteWithdrawalHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                              Hook for transfer                             //\n  // ========================================================================== //\n\n  // Size of caller + from + to + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant TransferHook_Base_Size = 0x0264;\n  uint256 internal constant TransferHook_From_Offset = 0x20;\n  uint256 internal constant TransferHook_To_Offset = 0x40;\n  uint256 internal constant TransferHook_ScaledAmount_Offset = 0x60;\n  uint256 internal constant TransferHook_State_Offset = 0x80;\n  uint256 internal constant TransferHook_ExtraData_Head_Offset = 0x220;\n  uint256 internal constant TransferHook_ExtraData_Length_Offset = 0x0240;\n  uint256 internal constant TransferHook_ExtraData_TailOffset = 0x0260;\n\n  function onTransfer(\n    HooksConfig self,\n    address from,\n    address to,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onTransferSelector = uint32(IHooks.onTransfer.selector);\n    if (self.useOnTransfer()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onTransfer`\n        mstore(cdPointer, onTransferSelector)\n        // Write `caller` to hook calldata\n        mstore(headPointer, caller())\n        // Write `from` to hook calldata\n        mstore(add(headPointer, TransferHook_From_Offset), from)\n        // Write `to` to hook calldata\n        mstore(add(headPointer, TransferHook_To_Offset), to)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, TransferHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, TransferHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, TransferHook_ExtraData_Head_Offset),\n          TransferHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, TransferHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, TransferHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(TransferHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                               Hook for borrow                              //\n  // ========================================================================== //\n\n  uint256 internal constant BorrowCalldataSize = 0x24;\n  // Size of normalizedAmount + state + extraData.offset + extraData.length\n  uint256 internal constant BorrowHook_Base_Size = 0x0204;\n  uint256 internal constant BorrowHook_State_Offset = 0x20;\n  uint256 internal constant BorrowHook_ExtraData_Head_Offset = 0x01c0;\n  uint256 internal constant BorrowHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant BorrowHook_ExtraData_TailOffset = 0x0200;\n\n  function onBorrow(HooksConfig self, uint256 normalizedAmount, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onBorrowSelector = uint32(IHooks.onBorrow.selector);\n    if (self.useOnBorrow()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), BorrowCalldataSize)\n        let ptr := mload(0x40)\n        let headPointer := add(ptr, 0x20)\n\n        mstore(ptr, onBorrowSelector)\n        // Copy `normalizedAmount` to hook calldata\n        mstore(headPointer, normalizedAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, BorrowHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, BorrowHook_ExtraData_Head_Offset),\n          BorrowHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, BorrowHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, BorrowHook_ExtraData_TailOffset),\n          BorrowCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(RepayHook_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                               Hook for repay                               //\n  // ========================================================================== //\n\n  // Size of normalizedAmount + state + extraData.offset + extraData.length\n  uint256 internal constant RepayHook_Base_Size = 0x0204;\n  uint256 internal constant RepayHook_State_Offset = 0x20;\n  uint256 internal constant RepayHook_ExtraData_Head_Offset = 0x01c0;\n  uint256 internal constant RepayHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant RepayHook_ExtraData_TailOffset = 0x0200;\n\n  function onRepay(\n    HooksConfig self,\n    uint256 normalizedAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onRepaySelector = uint32(IHooks.onRepay.selector);\n    if (self.useOnRepay()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let ptr := mload(0x40)\n        let headPointer := add(ptr, 0x20)\n\n        mstore(ptr, onRepaySelector)\n        // Copy `normalizedAmount` to hook calldata\n        mstore(headPointer, normalizedAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, RepayHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(add(headPointer, RepayHook_ExtraData_Head_Offset), RepayHook_ExtraData_Length_Offset)\n        // Write length for `extraData`\n        mstore(add(headPointer, RepayHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, RepayHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(RepayHook_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                            Hook for closeMarket                            //\n  // ========================================================================== //\n\n  // Size of calldata to `market.closeMarket`\n  uint256 internal constant CloseMarketCalldataSize = 0x04;\n\n  // Base size of calldata for `hooks.onCloseMarket()`\n  uint256 internal constant CloseMarketHook_Base_Size = 0x01e4;\n  uint256 internal constant CloseMarketHook_ExtraData_Head_Offset = MarketStateSize;\n  uint256 internal constant CloseMarketHook_ExtraData_Length_Offset = 0x01c0;\n  uint256 internal constant CloseMarketHook_ExtraData_TailOffset = 0x01e0;\n\n  function onCloseMarket(HooksConfig self, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onCloseMarketSelector = uint32(IHooks.onCloseMarket.selector);\n    if (self.useOnCloseMarket()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), CloseMarketCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onCloseMarket`\n        mstore(cdPointer, onCloseMarketSelector)\n        // Copy market state to hook calldata\n        mcopy(headPointer, state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, CloseMarketHook_ExtraData_Head_Offset),\n          CloseMarketHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, CloseMarketHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, CloseMarketHook_ExtraData_TailOffset),\n          CloseMarketCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(CloseMarketHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                         Hook for setMaxTotalSupply                         //\n  // ========================================================================== //\n\n  uint256 internal constant SetMaxTotalSupplyCalldataSize = 0x24;\n  // Size of maxTotalSupply + state + extraData.offset + extraData.length\n  uint256 internal constant SetMaxTotalSupplyHook_Base_Size = 0x0204;\n  uint256 internal constant SetMaxTotalSupplyHook_State_Offset = 0x20;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_Head_Offset = 0x01c0;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_TailOffset = 0x0200;\n\n  function onSetMaxTotalSupply(\n    HooksConfig self,\n    uint256 maxTotalSupply,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onSetMaxTotalSupplySelector = uint32(IHooks.onSetMaxTotalSupply.selector);\n    if (self.useOnSetMaxTotalSupply()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), SetMaxTotalSupplyCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetMaxTotalSupply`\n        mstore(cdPointer, onSetMaxTotalSupplySelector)\n        // Write `maxTotalSupply` to hook calldata\n        mstore(headPointer, maxTotalSupply)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, SetMaxTotalSupplyHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetMaxTotalSupplyHook_ExtraData_Head_Offset),\n          SetMaxTotalSupplyHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, SetMaxTotalSupplyHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetMaxTotalSupplyHook_ExtraData_TailOffset),\n          SetMaxTotalSupplyCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetMaxTotalSupplyHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                       Hook for setAnnualInterestBips                       //\n  // ========================================================================== //\n\n  uint256 internal constant SetAnnualInterestBipsCalldataSize = 0x44;\n  // Size of annualInterestBips + state + extraData.offset + extraData.length\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_Base_Size = 0x0224;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ReserveRatioBits_Offset = 0x20;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_State_Offset = 0x40;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset =\n    0x0200;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_TailOffset = 0x0220;\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    HooksConfig self,\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState memory state\n  ) internal returns (uint16 newAnnualInterestBips, uint16 newReserveRatioBips) {\n    address target = self.hooksAddress();\n    uint32 onSetAnnualInterestBipsSelector = uint32(\n      IHooks.onSetAnnualInterestAndReserveRatioBips.selector\n    );\n    if (self.useOnSetAnnualInterestAndReserveRatioBips()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), SetAnnualInterestBipsCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetAnnualInterestBips`\n        mstore(cdPointer, onSetAnnualInterestBipsSelector)\n        // Write `annualInterestBips` to hook calldata\n        mstore(headPointer, annualInterestBips)\n        // Write `reserveRatioBips` to hook calldata\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ReserveRatioBits_Offset),\n          reserveRatioBips\n        )\n        // Copy market state to hook calldata\n        mcopy(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_State_Offset),\n          state,\n          MarketStateSize\n        )\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Head_Offset),\n          SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset),\n          extraCalldataBytes\n        )\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_TailOffset),\n          SetAnnualInterestBipsCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetAnnualInterestAndReserveRatioBipsHook_Base_Size, extraCalldataBytes)\n\n        // Returndata is expected to have the new values for `annualInterestBips` and `reserveRatioBips`\n        if or(\n          lt(returndatasize(), 0x40),\n          iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0x40))\n        ) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n\n        newAnnualInterestBips := and(mload(0), 0xffff)\n        newReserveRatioBips := and(mload(0x20), 0xffff)\n      }\n    } else {\n      (newAnnualInterestBips, newReserveRatioBips) = (annualInterestBips, reserveRatioBips);\n    }\n  }\n\n  // ========================================================================== //\n  //                       Hook for assets sent to escrow                       //\n  // ========================================================================== //\n\n  // Size of lender + asset + escrow + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant AssetsSentToEscrowHook_Base_Size = 0x0264;\n  uint256 internal constant AssetsSentToEscrowHook_Asset_Offset = 0x20;\n  uint256 internal constant AssetsSentToEscrowHook_Escrow_Offset = 0x40;\n  uint256 internal constant AssetsSentToEscrowHook_ScaledAmount_Offset = 0x60;\n  uint256 internal constant AssetsSentToEscrowHook_State_Offset = 0x80;\n  uint256 internal constant AssetsSentToEscrowHook_ExtraData_Head_Offset = 0x220;\n  uint256 internal constant AssetsSentToEscrowHook_ExtraData_Length_Offset = 0x0240;\n  uint256 internal constant AssetsSentToEscrowHook_ExtraData_TailOffset = 0x0260;\n\n  function onAssetsSentToEscrow(\n    HooksConfig self,\n    address lender,\n    address asset,\n    address escrow,\n    uint scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onAssetsSentToEscrowSelector = uint32(IHooks.onAssetsSentToEscrow.selector);\n    if (self.useOnAssetsSentToEscrow()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onAssetsSentToEscrow`\n        mstore(cdPointer, onAssetsSentToEscrowSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `asset` to hook calldata\n        mstore(add(headPointer, AssetsSentToEscrowHook_Asset_Offset), asset)\n        // Write `escrow` to hook calldata\n        mstore(add(headPointer, AssetsSentToEscrowHook_Escrow_Offset), escrow)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, AssetsSentToEscrowHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, AssetsSentToEscrowHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, AssetsSentToEscrowHook_ExtraData_Head_Offset),\n          AssetsSentToEscrowHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, AssetsSentToEscrowHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, AssetsSentToEscrowHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(AssetsSentToEscrowHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n}\n"},"src/libraries/MarketState.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './MathUtils.sol';\nimport './SafeCastLib.sol';\nimport './FeeMath.sol';\n\nusing MarketStateLib for MarketState global;\nusing MarketStateLib for Account global;\nusing FeeMath for MarketState global;\n\nstruct MarketState {\n  bool isClosed;\n  uint128 maxTotalSupply;\n  uint128 accruedProtocolFees;\n  // Underlying assets reserved for withdrawals which have been paid\n  // by the borrower but not yet executed.\n  uint128 normalizedUnclaimedWithdrawals;\n  // Scaled token supply (divided by scaleFactor)\n  uint104 scaledTotalSupply;\n  // Scaled token amount in withdrawal batches that have not been\n  // paid by borrower yet.\n  uint104 scaledPendingWithdrawals;\n  uint32 pendingWithdrawalExpiry;\n  // Whether market is currently delinquent (liquidity under requirement)\n  bool isDelinquent;\n  // Seconds borrower has been delinquent\n  uint32 timeDelinquent;\n  // Annual interest rate accrued to lenders, in basis points\n  uint16 annualInterestBips;\n  // Percentage of outstanding balance that must be held in liquid reserves\n  uint16 reserveRatioBips;\n  // Ratio between internal balances and underlying token amounts\n  uint112 scaleFactor;\n  uint32 lastInterestAccruedTimestamp;\n}\n\nstruct Account {\n  uint104 scaledBalance;\n}\n\nlibrary MarketStateLib {\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n\n  /**\n   * @dev Returns the normalized total supply of the market.\n   */\n  function totalSupply(MarketState memory state) internal pure returns (uint256) {\n    return state.normalizeAmount(state.scaledTotalSupply);\n  }\n\n  /**\n   * @dev Returns the maximum amount of tokens that can be deposited without\n   *      reaching the maximum total supply.\n   */\n  function maximumDeposit(MarketState memory state) internal pure returns (uint256) {\n    return uint256(state.maxTotalSupply).satSub(state.totalSupply());\n  }\n\n  /**\n   * @dev Normalize an amount of scaled tokens using the current scale factor.\n   */\n  function normalizeAmount(\n    MarketState memory state,\n    uint256 amount\n  ) internal pure returns (uint256) {\n    return amount.rayMul(state.scaleFactor);\n  }\n\n  /**\n   * @dev Scale an amount of normalized tokens using the current scale factor.\n   */\n  function scaleAmount(MarketState memory state, uint256 amount) internal pure returns (uint256) {\n    return amount.rayDiv(state.scaleFactor);\n  }\n\n  /**\n   * @dev Collateralization requirement is:\n   *      - 100% of all pending (unpaid) withdrawals\n   *      - 100% of all unclaimed (paid) withdrawals\n   *      - reserve ratio times the outstanding debt (supply - pending withdrawals)\n   *      - accrued protocol fees\n   */\n  function liquidityRequired(\n    MarketState memory state\n  ) internal pure returns (uint256 _liquidityRequired) {\n    uint256 scaledWithdrawals = state.scaledPendingWithdrawals;\n    uint256 scaledRequiredReserves = (state.scaledTotalSupply - scaledWithdrawals).bipMul(\n      state.reserveRatioBips\n    ) + scaledWithdrawals;\n    return\n      state.normalizeAmount(scaledRequiredReserves) +\n      state.accruedProtocolFees +\n      state.normalizedUnclaimedWithdrawals;\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets that can be withdrawn\n   *      for protocol fees. The only debts with higher priority are\n   *      processed withdrawals that have not been executed.\n   */\n  function withdrawableProtocolFees(\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint128) {\n    uint256 totalAvailableAssets = totalAssets - state.normalizedUnclaimedWithdrawals;\n    return uint128(MathUtils.min(totalAvailableAssets, state.accruedProtocolFees));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets that can be borrowed.\n   *\n   *      The borrower must maintain sufficient assets in the market to\n   *      cover 100% of pending withdrawals, 100% of previously processed\n   *      withdrawals (before they are executed), and the reserve ratio\n   *      times the outstanding debt (deposits not pending withdrawal).\n   *\n   *      Any underlying assets in the market above this amount can be borrowed.\n   */\n  function borrowableAssets(\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint256) {\n    return totalAssets.satSub(state.liquidityRequired());\n  }\n\n  function hasPendingExpiredBatch(MarketState memory state) internal view returns (bool result) {\n    uint256 expiry = state.pendingWithdrawalExpiry;\n    assembly {\n      // Equivalent to expiry > 0 && expiry < block.timestamp\n      result := and(gt(expiry, 0), gt(timestamp(), expiry))\n    }\n  }\n\n  function totalDebts(MarketState memory state) internal pure returns (uint256) {\n    return\n      state.normalizeAmount(state.scaledTotalSupply) +\n      state.normalizedUnclaimedWithdrawals +\n      state.accruedProtocolFees;\n  }\n}\n"},"src/interfaces/WildcatStructsAndEnums.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport { MarketState } from '../libraries/MarketState.sol';\n\nimport { HooksConfig } from '../types/HooksConfig.sol';\n\nstruct MarketParameters {\n  address asset;\n  uint8 decimals;\n  bytes32 packedNameWord0;\n  bytes32 packedNameWord1;\n  bytes32 packedSymbolWord0;\n  bytes32 packedSymbolWord1;\n  address borrower;\n  address feeRecipient;\n  address sentinel;\n  uint128 maxTotalSupply;\n  uint16 protocolFeeBips;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  address archController;\n  address sphereXEngine;\n  HooksConfig hooks;\n}\n\nstruct DeployMarketInputs {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  HooksConfig hooks;\n}\n\nstruct MarketControllerParameters {\n  address archController;\n  address borrower;\n  address sentinel;\n  address marketInitCodeStorage;\n  uint256 marketInitCodeHash;\n  uint32 minimumDelinquencyGracePeriod;\n  uint32 maximumDelinquencyGracePeriod;\n  uint16 minimumReserveRatioBips;\n  uint16 maximumReserveRatioBips;\n  uint16 minimumDelinquencyFeeBips;\n  uint16 maximumDelinquencyFeeBips;\n  uint32 minimumWithdrawalBatchDuration;\n  uint32 maximumWithdrawalBatchDuration;\n  uint16 minimumAnnualInterestBips;\n  uint16 maximumAnnualInterestBips;\n  address sphereXEngine;\n}\n\nstruct ProtocolFeeConfiguration {\n  address feeRecipient;\n  address originationFeeAsset;\n  uint80 originationFeeAmount;\n  uint16 protocolFeeBips;\n}\n\nstruct MarketParameterConstraints {\n  uint32 minimumDelinquencyGracePeriod;\n  uint32 maximumDelinquencyGracePeriod;\n  uint16 minimumReserveRatioBips;\n  uint16 maximumReserveRatioBips;\n  uint16 minimumDelinquencyFeeBips;\n  uint16 maximumDelinquencyFeeBips;\n  uint32 minimumWithdrawalBatchDuration;\n  uint32 maximumWithdrawalBatchDuration;\n  uint16 minimumAnnualInterestBips;\n  uint16 maximumAnnualInterestBips;\n}\n"},"src/libraries/SafeCastLib.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './Errors.sol';\n\nlibrary SafeCastLib {\n  function _assertNonOverflow(bool didNotOverflow) private pure {\n    assembly {\n      if iszero(didNotOverflow) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n    }\n  }\n\n  function toUint8(uint256 x) internal pure returns (uint8 y) {\n    _assertNonOverflow(x == (y = uint8(x)));\n  }\n\n  function toUint16(uint256 x) internal pure returns (uint16 y) {\n    _assertNonOverflow(x == (y = uint16(x)));\n  }\n\n  function toUint24(uint256 x) internal pure returns (uint24 y) {\n    _assertNonOverflow(x == (y = uint24(x)));\n  }\n\n  function toUint32(uint256 x) internal pure returns (uint32 y) {\n    _assertNonOverflow(x == (y = uint32(x)));\n  }\n\n  function toUint40(uint256 x) internal pure returns (uint40 y) {\n    _assertNonOverflow(x == (y = uint40(x)));\n  }\n\n  function toUint48(uint256 x) internal pure returns (uint48 y) {\n    _assertNonOverflow(x == (y = uint48(x)));\n  }\n\n  function toUint56(uint256 x) internal pure returns (uint56 y) {\n    _assertNonOverflow(x == (y = uint56(x)));\n  }\n\n  function toUint64(uint256 x) internal pure returns (uint64 y) {\n    _assertNonOverflow(x == (y = uint64(x)));\n  }\n\n  function toUint72(uint256 x) internal pure returns (uint72 y) {\n    _assertNonOverflow(x == (y = uint72(x)));\n  }\n\n  function toUint80(uint256 x) internal pure returns (uint80 y) {\n    _assertNonOverflow(x == (y = uint80(x)));\n  }\n\n  function toUint88(uint256 x) internal pure returns (uint88 y) {\n    _assertNonOverflow(x == (y = uint88(x)));\n  }\n\n  function toUint96(uint256 x) internal pure returns (uint96 y) {\n    _assertNonOverflow(x == (y = uint96(x)));\n  }\n\n  function toUint104(uint256 x) internal pure returns (uint104 y) {\n    _assertNonOverflow(x == (y = uint104(x)));\n  }\n\n  function toUint112(uint256 x) internal pure returns (uint112 y) {\n    _assertNonOverflow(x == (y = uint112(x)));\n  }\n\n  function toUint120(uint256 x) internal pure returns (uint120 y) {\n    _assertNonOverflow(x == (y = uint120(x)));\n  }\n\n  function toUint128(uint256 x) internal pure returns (uint128 y) {\n    _assertNonOverflow(x == (y = uint128(x)));\n  }\n\n  function toUint136(uint256 x) internal pure returns (uint136 y) {\n    _assertNonOverflow(x == (y = uint136(x)));\n  }\n\n  function toUint144(uint256 x) internal pure returns (uint144 y) {\n    _assertNonOverflow(x == (y = uint144(x)));\n  }\n\n  function toUint152(uint256 x) internal pure returns (uint152 y) {\n    _assertNonOverflow(x == (y = uint152(x)));\n  }\n\n  function toUint160(uint256 x) internal pure returns (uint160 y) {\n    _assertNonOverflow(x == (y = uint160(x)));\n  }\n\n  function toUint168(uint256 x) internal pure returns (uint168 y) {\n    _assertNonOverflow(x == (y = uint168(x)));\n  }\n\n  function toUint176(uint256 x) internal pure returns (uint176 y) {\n    _assertNonOverflow(x == (y = uint176(x)));\n  }\n\n  function toUint184(uint256 x) internal pure returns (uint184 y) {\n    _assertNonOverflow(x == (y = uint184(x)));\n  }\n\n  function toUint192(uint256 x) internal pure returns (uint192 y) {\n    _assertNonOverflow(x == (y = uint192(x)));\n  }\n\n  function toUint200(uint256 x) internal pure returns (uint200 y) {\n    _assertNonOverflow(x == (y = uint200(x)));\n  }\n\n  function toUint208(uint256 x) internal pure returns (uint208 y) {\n    _assertNonOverflow(x == (y = uint208(x)));\n  }\n\n  function toUint216(uint256 x) internal pure returns (uint216 y) {\n    _assertNonOverflow(x == (y = uint216(x)));\n  }\n\n  function toUint224(uint256 x) internal pure returns (uint224 y) {\n    _assertNonOverflow(x == (y = uint224(x)));\n  }\n\n  function toUint232(uint256 x) internal pure returns (uint232 y) {\n    _assertNonOverflow(x == (y = uint232(x)));\n  }\n\n  function toUint240(uint256 x) internal pure returns (uint240 y) {\n    _assertNonOverflow(x == (y = uint240(x)));\n  }\n\n  function toUint248(uint256 x) internal pure returns (uint248 y) {\n    _assertNonOverflow(x == (y = uint248(x)));\n  }\n}\n"},"src/libraries/FeeMath.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.20;\n\nimport './MathUtils.sol';\nimport './SafeCastLib.sol';\nimport './MarketState.sol';\n\nusing SafeCastLib for uint256;\nusing MathUtils for uint256;\n\nlibrary FeeMath {\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   *\n   * @param rateBip The interest rate, in bips\n   * @param timeDelta The time elapsed since the last interest accrual\n   * @return result The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterestFromBips(\n    uint256 rateBip,\n    uint256 timeDelta\n  ) internal pure returns (uint256 result) {\n    uint256 rate = rateBip.bipToRay();\n    uint256 accumulatedInterestRay = rate * timeDelta;\n    unchecked {\n      return accumulatedInterestRay / SECONDS_IN_365_DAYS;\n    }\n  }\n\n  function calculateBaseInterest(\n    MarketState memory state,\n    uint256 timestamp\n  ) internal pure returns (uint256 baseInterestRay) {\n    baseInterestRay = MathUtils.calculateLinearInterestFromBips(\n      state.annualInterestBips,\n      timestamp - state.lastInterestAccruedTimestamp\n    );\n  }\n\n  function applyProtocolFee(\n    MarketState memory state,\n    uint256 baseInterestRay,\n    uint256 protocolFeeBips\n  ) internal pure returns (uint256 protocolFee) {\n    // Protocol fee is charged in addition to the interest paid to lenders.\n    uint256 protocolFeeRay = protocolFeeBips.bipMul(baseInterestRay);\n    protocolFee = uint256(state.scaledTotalSupply).rayMul(\n      uint256(state.scaleFactor).rayMul(protocolFeeRay)\n    );\n    state.accruedProtocolFees = (state.accruedProtocolFees + protocolFee).toUint128();\n  }\n\n  function updateDelinquency(\n    MarketState memory state,\n    uint256 timestamp,\n    uint256 delinquencyFeeBips,\n    uint256 delinquencyGracePeriod\n  ) internal pure returns (uint256 delinquencyFeeRay) {\n    // Calculate the number of seconds the borrower spent in penalized\n    // delinquency since the last update.\n    uint256 timeWithPenalty = updateTimeDelinquentAndGetPenaltyTime(\n      state,\n      delinquencyGracePeriod,\n      timestamp - state.lastInterestAccruedTimestamp\n    );\n\n    if (timeWithPenalty > 0) {\n      // Calculate penalty fees on the interest accrued.\n      delinquencyFeeRay = calculateLinearInterestFromBips(delinquencyFeeBips, timeWithPenalty);\n    }\n  }\n\n  /**\n   * @notice  Calculate the number of seconds that the market has been in\n   *          penalized delinquency since the last update, and update\n   *          `timeDelinquent` in state.\n   *\n   * @dev When `isDelinquent`, equivalent to:\n   *        max(0, timeDelta - max(0, delinquencyGracePeriod - previousTimeDelinquent))\n   *      When `!isDelinquent`, equivalent to:\n   *        min(timeDelta, max(0, previousTimeDelinquent - delinquencyGracePeriod))\n   *\n   * @param state Encoded state parameters\n   * @param delinquencyGracePeriod Seconds in delinquency before penalties apply\n   * @param timeDelta Seconds since the last update\n   * @param `timeWithPenalty` Number of seconds since the last update where\n   *        the market was in delinquency outside of the grace period.\n   */\n  function updateTimeDelinquentAndGetPenaltyTime(\n    MarketState memory state,\n    uint256 delinquencyGracePeriod,\n    uint256 timeDelta\n  ) internal pure returns (uint256 /* timeWithPenalty */) {\n    // Seconds in delinquency at last update\n    uint256 previousTimeDelinquent = state.timeDelinquent;\n\n    if (state.isDelinquent) {\n      // Since the borrower is still delinquent, increase the total\n      // time in delinquency by the time elapsed.\n      state.timeDelinquent = (previousTimeDelinquent + timeDelta).toUint32();\n\n      // Calculate the number of seconds the borrower had remaining\n      // in the grace period.\n      uint256 secondsRemainingWithoutPenalty = delinquencyGracePeriod.satSub(\n        previousTimeDelinquent\n      );\n\n      // Penalties apply for the number of seconds the market spent in\n      // delinquency outside of the grace period since the last update.\n      return timeDelta.satSub(secondsRemainingWithoutPenalty);\n    }\n\n    // Reduce the total time in delinquency by the time elapsed, stopping\n    // when it reaches zero.\n    state.timeDelinquent = previousTimeDelinquent.satSub(timeDelta).toUint32();\n\n    // Calculate the number of seconds the old timeDelinquent had remaining\n    // outside the grace period, or zero if it was already in the grace period.\n    uint256 secondsRemainingWithPenalty = previousTimeDelinquent.satSub(delinquencyGracePeriod);\n\n    // Only apply penalties for the remaining time outside of the grace period.\n    return MathUtils.min(secondsRemainingWithPenalty, timeDelta);\n  }\n\n  /**\n   * @dev Calculates interest and delinquency/protocol fees accrued since last state update\n   *      and applies it to cached state, returning the rates for base interest and delinquency\n   *      fees and the normalized amount of protocol fees accrued.\n   *\n   *      Takes `timestamp` as input to allow separate calculation of interest\n   *      before and after withdrawal batch expiry.\n   *\n   * @param state Market scale parameters\n   * @param protocolFeeBips Protocol fee rate (in bips)\n   * @param delinquencyFeeBips Delinquency fee rate (in bips)\n   * @param delinquencyGracePeriod Grace period (in seconds) before delinquency fees apply\n   * @param timestamp Time to calculate interest and fees accrued until\n   * @return baseInterestRay Interest accrued to lenders (ray)\n   * @return delinquencyFeeRay Penalty fee incurred by borrower for delinquency (ray).\n   * @return protocolFee Protocol fee charged on interest (normalized token amount).\n   */\n  function updateScaleFactorAndFees(\n    MarketState memory state,\n    uint256 protocolFeeBips,\n    uint256 delinquencyFeeBips,\n    uint256 delinquencyGracePeriod,\n    uint256 timestamp\n  )\n    internal\n    pure\n    returns (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee)\n  {\n    baseInterestRay = state.calculateBaseInterest(timestamp);\n\n    if (protocolFeeBips > 0) {\n      protocolFee = state.applyProtocolFee(baseInterestRay, protocolFeeBips);\n    }\n\n    if (delinquencyFeeBips > 0) {\n      delinquencyFeeRay = state.updateDelinquency(\n        timestamp,\n        delinquencyFeeBips,\n        delinquencyGracePeriod\n      );\n    }\n\n    // Calculate new scaleFactor\n    uint256 prevScaleFactor = state.scaleFactor;\n    uint256 scaleFactorDelta = prevScaleFactor.rayMul(baseInterestRay + delinquencyFeeRay);\n\n    state.scaleFactor = (prevScaleFactor + scaleFactorDelta).toUint112();\n    state.lastInterestAccruedTimestamp = uint32(timestamp);\n  }\n}\n"}},"settings":{"remappings":["src/=src/","forge-std/=lib/forge-std/src/","ds-test/=lib/ds-test/src/","solmate/=lib/solmate/src/","solady/=lib/solady/src/","openzeppelin/=lib/openzeppelin-contracts/","sol-utils/=lib/sol-utils/src/","ethereum-access-token/=lib/ethereum-access-token/contracts/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","openzeppelin-contracts/=lib/openzeppelin-contracts/","vulcan/=lib/vulcan/src/"],"optimizer":{"enabled":true,"runs":4294967295},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","ir","irOptimized","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
